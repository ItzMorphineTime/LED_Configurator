<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta author="Joe Loe">
    <title>LED Wall Configurator</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;500;600&family=Outfit:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg-primary: #0a0a0f;
            --bg-secondary: #12121a;
            --bg-tertiary: #1a1a24;
            --accent-cyan: #00f0ff;
            --accent-magenta: #ff00aa;
            --accent-orange: #ff6b35;
            --accent-green: #00ff66;
            --text-primary: #e8e8ec;
            --text-secondary: #8a8a9a;
            --text-dim: #4a4a5a;
            --border-color: #2a2a3a;
            --glow-cyan: 0 0 20px rgba(0, 240, 255, 0.3);
        }

        body {
            font-family: 'Outfit', sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            min-height: 100vh;
            overflow: hidden;
        }

        .app-container {
            display: grid;
            grid-template-columns: 400px 1fr;
            grid-template-rows: 60px 1fr;
            height: 100vh;
        }

        .header {
            grid-column: 1 / -1;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 24px;
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .logo-icon {
            width: 36px;
            height: 36px;
            background: linear-gradient(135deg, var(--accent-cyan), var(--accent-magenta));
            border-radius: 8px;
        }

        .logo-text {
            font-weight: 600;
            font-size: 18px;
        }

        .logo-text span {
            color: var(--accent-cyan);
        }

        .header-stats {
            display: flex;
            gap: 32px;
        }

        .stat {
            text-align: center;
        }

        .stat-value {
            font-family: 'JetBrains Mono', monospace;
            font-size: 18px;
            color: var(--accent-cyan);
            text-shadow: var(--glow-cyan);
        }

        .stat-label {
            font-size: 11px;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-top: 2px;
        }

        .control-panel {
            background: var(--bg-secondary);
            border-right: 1px solid var(--border-color);
            overflow-y: auto;
            padding: 16px;
        }

        .control-panel::-webkit-scrollbar {
            width: 6px;
        }

        .control-panel::-webkit-scrollbar-track {
            background: var(--bg-tertiary);
        }

        .control-panel::-webkit-scrollbar-thumb {
            background: var(--border-color);
            border-radius: 3px;
        }

        .wall-sections {
            display: flex;
            flex-direction: column;
            gap: 12px;
            margin-bottom: 16px;
        }

        .wall-section {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 10px;
            overflow: hidden;
        }

        .wall-section.collapsed .section-content {
            display: none;
        }

        .section-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 14px;
            cursor: pointer;
            background: var(--bg-tertiary);
            border-bottom: 1px solid transparent;
            transition: all 0.2s ease;
        }

        .wall-section:not(.collapsed) .section-header {
            border-bottom-color: var(--border-color);
        }

        .section-header:hover {
            background: rgba(0, 240, 255, 0.05);
        }

        .section-header-left {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .section-color {
            width: 12px;
            height: 12px;
            border-radius: 3px;
        }

        .section-title {
            font-weight: 600;
            font-size: 14px;
        }

        .section-summary {
            font-size: 11px;
            color: var(--text-secondary);
            font-family: 'JetBrains Mono', monospace;
        }

        .section-header-right {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .section-toggle {
            width: 24px;
            height: 24px;
            display: grid;
            place-items: center;
            color: var(--text-secondary);
            transition: transform 0.2s ease;
        }

        .wall-section.collapsed .section-toggle {
            transform: rotate(-90deg);
        }

        .section-delete {
            width: 24px;
            height: 24px;
            display: grid;
            place-items: center;
            color: var(--text-secondary);
            background: transparent;
            border: none;
            cursor: pointer;
            border-radius: 4px;
            transition: all 0.2s ease;
        }

        .section-delete:hover {
            color: #ff4444;
            background: rgba(255, 68, 68, 0.1);
        }

        .section-content {
            padding: 14px;
        }

        .section-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 12px;
        }

        .section-row.single {
            grid-template-columns: 1fr;
        }

        .input-field {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 10px;
            transition: border-color 0.2s ease;
        }

        .input-field:focus-within {
            border-color: var(--accent-cyan);
        }

        .input-field label {
            display: block;
            font-size: 9px;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: var(--text-secondary);
            margin-bottom: 4px;
        }

        .input-field input {
            width: 100%;
            background: transparent;
            border: none;
            color: var(--text-primary);
            font-family: 'JetBrains Mono', monospace;
            font-size: 14px;
            outline: none;
        }

        .curve-hint {
            font-size: 10px;
            color: var(--text-secondary);
            font-style: italic;
            margin-top: 4px;
        }

        .add-section-btn {
            width: 100%;
            padding: 12px;
            background: transparent;
            border: 2px dashed var(--border-color);
            border-radius: 10px;
            color: var(--text-secondary);
            font-family: 'Outfit', sans-serif;
            font-size: 13px;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .add-section-btn:hover {
            border-color: var(--accent-cyan);
            color: var(--accent-cyan);
            background: rgba(0, 240, 255, 0.05);
        }

        .global-section {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 10px;
            padding: 14px;
            margin-bottom: 16px;
        }

        .global-section-title {
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            color: var(--text-secondary);
            margin-bottom: 14px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .global-section-title::before {
            content: '';
            width: 3px;
            height: 12px;
            background: var(--accent-magenta);
            border-radius: 2px;
        }

        .mesh-mode-select {
            display: flex;
            flex-direction: column;
            gap: 6px;
            margin-bottom: 14px;
        }

        .mesh-mode-option {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 12px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .mesh-mode-option:hover {
            border-color: var(--accent-cyan);
        }

        .mesh-mode-option.active {
            background: rgba(0, 240, 255, 0.1);
            border-color: var(--accent-cyan);
        }

        .mesh-mode-option input {
            display: none;
        }

        .mesh-mode-radio {
            width: 16px;
            height: 16px;
            border: 2px solid var(--border-color);
            border-radius: 50%;
            position: relative;
        }

        .mesh-mode-option.active .mesh-mode-radio {
            border-color: var(--accent-cyan);
        }

        .mesh-mode-option.active .mesh-mode-radio::after {
            content: '';
            position: absolute;
            top: 3px;
            left: 3px;
            width: 6px;
            height: 6px;
            background: var(--accent-cyan);
            border-radius: 50%;
        }

        .mesh-mode-label {
            font-size: 12px;
        }

        .toggle-container {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 10px 0;
        }

        .toggle-label {
            font-size: 13px;
        }

        .toggle {
            width: 44px;
            height: 24px;
            background: var(--bg-primary);
            border-radius: 12px;
            cursor: pointer;
            position: relative;
            transition: background 0.3s ease;
        }

        .toggle.active {
            background: var(--accent-cyan);
        }

        .toggle::after {
            content: '';
            position: absolute;
            width: 18px;
            height: 18px;
            background: white;
            border-radius: 50%;
            top: 3px;
            left: 3px;
            transition: transform 0.3s ease;
        }

        .toggle.active::after {
            transform: translateX(20px);
        }

        .export-btn {
            width: 100%;
            padding: 14px;
            background: linear-gradient(135deg, var(--accent-cyan), var(--accent-magenta));
            border: none;
            border-radius: 8px;
            color: white;
            font-family: 'Outfit', sans-serif;
            font-size: 13px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .export-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 30px rgba(0, 240, 255, 0.3);
        }

        .viewport {
            position: relative;
            background: var(--bg-primary);
            overflow: hidden;
        }

        #three-canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        .viewport-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
        }

        .grid-lines {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-image: 
                linear-gradient(rgba(0, 240, 255, 0.03) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 240, 255, 0.03) 1px, transparent 1px);
            background-size: 50px 50px;
        }

        .viewport-info {
            position: absolute;
            bottom: 20px;
            left: 20px;
        }

        .info-badge {
            background: rgba(18, 18, 26, 0.9);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 8px 12px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 11px;
            color: var(--text-secondary);
        }

        .viewport-controls {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            pointer-events: all;
        }

        .gizmo-controls {
            position: absolute;
            top: 20px;
            left: 20px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            pointer-events: all;
        }

        .gizmo-mode-btn {
            width: 40px;
            height: 40px;
            background: rgba(18, 18, 26, 0.9);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            cursor: pointer;
            display: grid;
            place-items: center;
            transition: all 0.2s ease;
            color: var(--text-secondary);
            font-size: 11px;
            font-weight: 600;
        }

        .gizmo-mode-btn:hover {
            border-color: var(--accent-cyan);
            color: var(--accent-cyan);
        }

        .gizmo-mode-btn.active {
            background: var(--accent-cyan);
            border-color: var(--accent-cyan);
            color: #000;
        }

        .gizmo-mode-btn.translate.active {
            background: #ffaa00;
            border-color: #ffaa00;
        }

        .gizmo-mode-btn.rotate.active {
            background: #00aaff;
            border-color: #00aaff;
        }

        .gizmo-mode-btn.pilot.active {
            background: #ff4466;
            border-color: #ff4466;
        }

        .gizmo-mode-btn.space {
            font-weight: 700;
            font-size: 14px;
        }

        .gizmo-mode-btn.space.world {
            background: rgba(100, 100, 100, 0.8);
            border-color: #888;
            color: #fff;
        }

        .gizmo-mode-btn.space.local {
            background: #aa66ff;
            border-color: #aa66ff;
            color: #fff;
        }

        .pilot-info {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 68, 102, 0.95);
            border: 2px solid #ff4466;
            border-radius: 8px;
            padding: 10px 20px;
            font-size: 12px;
            font-weight: 600;
            color: #fff;
            pointer-events: none;
            display: none;
            z-index: 100;
            white-space: nowrap;
        }

        .pilot-info.visible {
            display: block;
        }

        .gizmo-divider {
            width: 100%;
            height: 1px;
            background: var(--border-color);
            margin: 4px 0;
        }

        .selection-indicator {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(18, 18, 26, 0.9);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 8px 14px;
            font-size: 11px;
            color: var(--text-secondary);
            pointer-events: none;
            display: none;
        }

        .selection-indicator.visible {
            display: block;
        }

        .selection-indicator .selected-name {
            color: var(--accent-cyan);
            font-weight: 600;
        }

        .view-btn {
            width: 40px;
            height: 40px;
            background: rgba(18, 18, 26, 0.9);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            cursor: pointer;
            display: grid;
            place-items: center;
            transition: all 0.2s ease;
            color: var(--text-secondary);
        }

        .view-btn:hover {
            border-color: var(--accent-cyan);
            color: var(--accent-cyan);
        }

        .view-btn svg {
            width: 18px;
            height: 18px;
        }

        .section-color-0 { background: #00f0ff; }
        .section-color-1 { background: #ff00aa; }
        .section-color-2 { background: #00ff66; }
        .section-color-3 { background: #ff6b35; }
        .section-color-4 { background: #ffdd00; }
        .section-color-5 { background: #aa66ff; }
        .section-color-6 { background: #66ffaa; }
        .section-color-7 { background: #ff6666; }

        .section-color-picker {
            display: flex;
            gap: 6px;
            align-items: center;
            margin-top: 6px;
        }

        .color-swatch-small {
            width: 24px;
            height: 24px;
            border-radius: 4px;
            cursor: pointer;
            border: 2px solid transparent;
            transition: all 0.2s ease;
        }

        .color-swatch-small:hover {
            transform: scale(1.1);
        }

        .color-swatch-small.active {
            border-color: white;
            box-shadow: 0 0 8px currentColor;
        }

        .color-input-custom {
            width: 28px;
            height: 24px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            background: transparent;
            padding: 0;
        }

        .color-input-custom::-webkit-color-swatch-wrapper {
            padding: 0;
        }

        .color-input-custom::-webkit-color-swatch {
            border: 1px solid var(--border-color);
            border-radius: 4px;
        }

        .section-warning {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 10px 12px;
            background: rgba(255, 107, 53, 0.15);
            border: 1px solid rgba(255, 107, 53, 0.4);
            border-radius: 6px;
            margin-bottom: 12px;
            color: #ff6b35;
            font-size: 11px;
        }

        .section-warning svg {
            flex-shrink: 0;
            stroke: #ff6b35;
        }

        .warning-indicator {
            color: #ff6b35;
            font-size: 12px;
        }

        .export-section {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .export-row {
            display: flex;
            gap: 8px;
        }

        .export-btn {
            flex: 1;
            padding: 12px;
            background: linear-gradient(135deg, var(--accent-cyan), var(--accent-magenta));
            border: none;
            border-radius: 8px;
            color: white;
            font-family: 'Outfit', sans-serif;
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .export-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 30px rgba(0, 240, 255, 0.3);
        }

        .export-btn.secondary {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
        }

        .export-btn.secondary:hover {
            border-color: var(--accent-cyan);
            box-shadow: 0 5px 20px rgba(0, 240, 255, 0.2);
        }

        .import-input {
            display: none;
        }

        @media (max-width: 900px) {
            .app-container {
                grid-template-columns: 1fr;
                grid-template-rows: 60px 1fr 350px;
            }
            .control-panel {
                order: 3;
                border-right: none;
                border-top: 1px solid var(--border-color);
            }
        }
    </style>
</head>
<body>
    <div class="app-container">
        <header class="header">
            <div class="logo">
                <div class="logo-icon"></div>
                <div class="logo-text">LED<span>WALL</span> Configurator</div>
            </div>
            <div class="header-stats">
                <div class="stat">
                    <div class="stat-value" id="total-pixels">0</div>
                    <div class="stat-label">Total Pixels</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="total-panels">0</div>
                    <div class="stat-label">Panels</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="total-sections">0</div>
                    <div class="stat-label">Sections</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="total-arc">0Â°</div>
                    <div class="stat-label">Total Arc</div>
                </div>
            </div>
        </header>

        <aside class="control-panel">
            <div class="wall-sections" id="wall-sections"></div>

            <button class="add-section-btn" id="add-section-btn">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <line x1="12" y1="5" x2="12" y2="19"></line>
                    <line x1="5" y1="12" x2="19" y2="12"></line>
                </svg>
                Add Wall Section
            </button>

            <div class="global-section" style="margin-top: 16px;">
                <div class="global-section-title">Mesh Options</div>
                <div class="mesh-mode-select" id="mesh-mode-select">
                    <label class="mesh-mode-option active" data-mode="combined">
                        <input type="radio" name="mesh-mode" value="combined" checked>
                        <span class="mesh-mode-radio"></span>
                        <span class="mesh-mode-label">Single Combined Mesh</span>
                    </label>
                    <label class="mesh-mode-option" data-mode="section">
                        <input type="radio" name="mesh-mode" value="section">
                        <span class="mesh-mode-radio"></span>
                        <span class="mesh-mode-label">Individual Section Meshes</span>
                    </label>
                    <label class="mesh-mode-option" data-mode="panel">
                        <input type="radio" name="mesh-mode" value="panel">
                        <span class="mesh-mode-radio"></span>
                        <span class="mesh-mode-label">Individual Panels</span>
                    </label>
                </div>
                <div class="toggle-container">
                    <span class="toggle-label">Wireframe</span>
                    <div class="toggle" id="toggle-wireframe"></div>
                </div>
                <div class="toggle-container">
                    <span class="toggle-label">Show Panel Frames</span>
                    <div class="toggle" id="toggle-frame"></div>
                </div>
            </div>

            <div class="global-section">
                <div class="global-section-title">Display</div>
                <div class="toggle-container">
                    <span class="toggle-label">Simulate LED Pixels</span>
                    <div class="toggle" id="toggle-led-sim"></div>
                </div>
                <div class="toggle-container" id="animation-toggle-container" style="display: none;">
                    <span class="toggle-label">Animate LEDs</span>
                    <div class="toggle" id="toggle-animation"></div>
                </div>
            </div>

            <div class="global-section">
                <div class="global-section-title">Panel IDs</div>
                <div class="toggle-container">
                    <span class="toggle-label">Show Panel Labels</span>
                    <div class="toggle" id="toggle-panel-ids"></div>
                </div>
                <div id="panel-id-options" style="display: none;">
                    <div class="input-field" style="margin-top: 10px;">
                        <label>Border Thickness (px)</label>
                        <input type="number" id="panel-border-thickness" value="8" min="1" max="32">
                    </div>
                    <div class="input-field" style="margin-top: 10px;">
                        <label>Label Font Size (0=auto)</label>
                        <input type="number" id="panel-font-size" value="0" min="0" max="200">
                    </div>
                    <div class="input-field" style="margin-top: 10px;">
                        <label>Label Font Color</label>
                        <input type="color" id="panel-font-color" value="#ffffff" style="width: 100%; height: 30px; cursor: pointer;">
                    </div>
                    <div class="toggle-container" style="margin-top: 10px;">
                        <span class="toggle-label">Show Section Names</span>
                        <div class="toggle active" id="toggle-section-labels"></div>
                    </div>
                    <div class="input-field" style="margin-top: 10px;">
                        <label>Section Label Size (0=auto)</label>
                        <input type="number" id="section-label-size" value="0" min="0" max="400">
                    </div>
                    <div class="input-field" style="margin-top: 10px;">
                        <label>Section Label Color</label>
                        <input type="color" id="section-label-color" value="#888888" style="width: 100%; height: 30px; cursor: pointer;">
                    </div>
                </div>
            </div>

            <div class="global-section">
                <div class="global-section-title">Camera Frustum Preview</div>
                <div class="toggle-container">
                    <span class="toggle-label">Enable Camera Preview</span>
                    <div class="toggle" id="toggle-camera-preview"></div>
                </div>
                <div id="camera-preview-options" style="display: none;">
                    <div class="input-field" style="margin-top: 10px;">
                        <label>Filmback / Sensor</label>
                        <select id="camera-filmback" style="width: 100%; background: var(--bg-tertiary); border: 1px solid var(--border-color); color: var(--text-primary); padding: 6px; border-radius: 4px; font-size: 12px;">
                            <option value="full-frame">Full Frame (36Ã—24mm)</option>
                            <option value="super35">Super 35 (24.89Ã—18.66mm)</option>
                            <option value="arri-lf">ARRI LF (36.70Ã—25.54mm)</option>
                            <option value="arri-alexa">ARRI Alexa (28.17Ã—18.13mm)</option>
                            <option value="red-v-raptor">RED V-RAPTOR (40.96Ã—21.60mm)</option>
                            <option value="red-komodo">RED KOMODO (27.03Ã—14.26mm)</option>
                            <option value="sony-venice">Sony VENICE (36Ã—24mm)</option>
                            <option value="bmpcc-6k">BMPCC 6K (23.10Ã—12.99mm)</option>
                            <option value="aps-c">APS-C (23.6Ã—15.6mm)</option>
                            <option value="mft">Micro 4/3 (17.3Ã—13mm)</option>
                            <option value="custom">Custom</option>
                        </select>
                    </div>
                    <div id="custom-filmback" style="display: none;">
                        <div class="section-row" style="margin-top: 10px; margin-bottom: 0;">
                            <div class="input-field">
                                <label>Sensor Width (mm)</label>
                                <input type="number" id="filmback-width" value="36" min="1" max="100" step="0.01">
                            </div>
                            <div class="input-field">
                                <label>Sensor Height (mm)</label>
                                <input type="number" id="filmback-height" value="24" min="1" max="100" step="0.01">
                            </div>
                        </div>
                    </div>
                    <div class="input-field" style="margin-top: 10px;">
                        <label>Focal Length (mm)</label>
                        <input type="number" id="camera-focal-length" value="35" min="8" max="800" step="1">
                    </div>
                    <div class="camera-info" style="margin-top: 10px; padding: 10px; background: var(--bg-secondary); border-radius: 6px; font-size: 11px;">
                        <div style="display: flex; justify-content: space-between; margin-bottom: 4px;">
                            <span style="color: var(--text-secondary);">H-FOV:</span>
                            <span id="camera-hfov" style="color: var(--accent-cyan);">54.4Â°</span>
                        </div>
                        <div style="display: flex; justify-content: space-between; margin-bottom: 4px;">
                            <span style="color: var(--text-secondary);">V-FOV:</span>
                            <span id="camera-vfov" style="color: var(--accent-cyan);">37.8Â°</span>
                        </div>
                        <div style="display: flex; justify-content: space-between;">
                            <span style="color: var(--text-secondary);">Aspect:</span>
                            <span id="camera-aspect" style="color: var(--accent-cyan);">1.50:1</span>
                        </div>
                    </div>
                    <div class="subsection-title" style="margin-top: 14px; margin-bottom: 8px; font-size: 10px; text-transform: uppercase; letter-spacing: 1px; color: var(--text-secondary);">Camera Position</div>
                    <div class="section-row" style="margin-bottom: 8px;">
                        <div class="input-field">
                            <label>X Position (m)</label>
                            <input type="number" id="camera-pos-x" value="0" step="0.1">
                        </div>
                        <div class="input-field">
                            <label>Y Height (m)</label>
                            <input type="number" id="camera-pos-y" value="1.5" min="0" step="0.1">
                        </div>
                    </div>
                    <div class="input-field" style="margin-bottom: 10px;">
                        <label>Z Distance from Wall (m)</label>
                        <input type="number" id="camera-pos-z" value="5" min="0.1" step="0.1">
                    </div>
                    <div class="subsection-title" style="margin-top: 6px; margin-bottom: 8px; font-size: 10px; text-transform: uppercase; letter-spacing: 1px; color: var(--text-secondary);">Camera Rotation</div>
                    <div class="section-row" style="margin-bottom: 8px;">
                        <div class="input-field">
                            <label>Tilt (Â°)</label>
                            <input type="number" id="camera-rot-x" value="0" min="-90" max="90" step="0.5">
                        </div>
                        <div class="input-field">
                            <label>Pan (Â°)</label>
                            <input type="number" id="camera-rot-y" value="0" min="-180" max="360" step="0.5">
                        </div>
                    </div>
                    <div class="section-row single" style="margin-bottom: 10px;">
                        <div class="input-field">
                            <label>Roll (Â°)</label>
                            <input type="number" id="camera-rot-z" value="0" min="-180" max="180" step="0.5">
                        </div>
                    </div>
                    <div class="frustum-status" style="margin-top: 10px; padding: 10px; background: var(--bg-secondary); border-radius: 6px; font-size: 11px;">
                        <div style="display: flex; justify-content: space-between; margin-bottom: 4px;">
                            <span style="color: var(--text-secondary);">Frame Width at Wall:</span>
                            <span id="frustum-width" style="color: var(--accent-cyan);">--</span>
                        </div>
                        <div style="display: flex; justify-content: space-between; margin-bottom: 4px;">
                            <span style="color: var(--text-secondary);">Frame Height at Wall:</span>
                            <span id="frustum-height" style="color: var(--accent-cyan);">--</span>
                        </div>
                        <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                            <span style="color: var(--text-secondary);">Status:</span>
                            <span id="frustum-status-text" style="color: #ffaa00;">--</span>
                        </div>
                        <div style="display: flex; justify-content: space-between;">
                            <span style="color: var(--text-secondary);">Max Distance:</span>
                            <span id="safe-distance" style="color: #00ff66;">--</span>
                        </div>
                    </div>
                    <div class="toggle-container" style="margin-top: 12px;">
                        <span class="toggle-label">Show Safe Distance 3D</span>
                        <div class="toggle" id="toggle-safe-distance"></div>
                    </div>
                    <button class="export-btn secondary" id="reset-camera" style="margin-top: 10px; width: 100%;">Reset Camera Position</button>
                    <button class="export-btn secondary" id="export-safe-distance" style="margin-top: 6px; width: 100%; display: none;">Export Safe Distance OBJ</button>
                </div>
            </div>

            <div class="global-section">
                <div class="global-section-title">Scene Props</div>
                <div class="toggle-container">
                    <span class="toggle-label">Show Person</span>
                    <div class="toggle" id="toggle-person"></div>
                </div>
                <div id="person-options" style="display: none; margin-top: 10px;">
                    <div class="section-row" style="margin-bottom: 8px;">
                        <div class="input-field">
                            <label>X Position (m)</label>
                            <input type="number" id="person-pos-x" value="2" step="0.1">
                        </div>
                        <div class="input-field">
                            <label>Z Position (m)</label>
                            <input type="number" id="person-pos-z" value="2" step="0.1">
                        </div>
                    </div>
                    <div class="section-row" style="margin-bottom: 8px;">
                        <div class="input-field">
                            <label>Rotation (Â°)</label>
                            <input type="number" id="person-rot-y" value="0" min="-180" max="180" step="5">
                        </div>
                        <div class="input-field">
                            <label>Scale</label>
                            <input type="number" id="person-scale" value="1" min="0.5" max="2" step="0.1">
                        </div>
                    </div>
                </div>
                
                <div class="toggle-container" style="margin-top: 12px;">
                    <span class="toggle-label">Show Car</span>
                    <div class="toggle" id="toggle-car"></div>
                </div>
                <div id="car-options" style="display: none; margin-top: 10px;">
                    <div class="section-row" style="margin-bottom: 8px;">
                        <div class="input-field">
                            <label>X Position (m)</label>
                            <input type="number" id="car-pos-x" value="4" step="0.1">
                        </div>
                        <div class="input-field">
                            <label>Z Position (m)</label>
                            <input type="number" id="car-pos-z" value="3" step="0.1">
                        </div>
                    </div>
                    <div class="section-row" style="margin-bottom: 8px;">
                        <div class="input-field">
                            <label>Rotation (Â°)</label>
                            <input type="number" id="car-rot-y" value="0" min="-180" max="180" step="5">
                        </div>
                        <div class="input-field">
                            <label>Scale</label>
                            <input type="number" id="car-scale" value="1" min="0.5" max="2" step="0.1">
                        </div>
                    </div>
                </div>
            </div>

            <div class="export-section">
                <div class="export-row">
                    <button class="export-btn" id="export-zip">Export All (ZIP)</button>
                </div>
                <div class="export-row">
                    <button class="export-btn secondary" id="export-panel-ids">Export Panel IDs</button>
                </div>
                <div class="export-row">
                    <button class="export-btn secondary" id="export-json">Export JSON</button>
                    <button class="export-btn secondary" id="import-json">Import JSON</button>
                </div>
                <div class="export-row">
                    <button class="export-btn secondary" id="export-obj">Export OBJ</button>
                    <button class="export-btn secondary" id="export-gltf">Export glTF</button>
                </div>
                <input type="file" id="import-input" class="import-input" accept=".json">
            </div>
        </aside>

        <main class="viewport">
            <canvas id="three-canvas"></canvas>
            <div id="camera-preview-window" style="display: none; position: absolute; bottom: 20px; right: 20px; width: 320px; height: 180px; background: #000; border: 2px solid var(--accent-cyan); border-radius: 8px; overflow: hidden; box-shadow: 0 4px 20px rgba(0, 240, 255, 0.3);">
                <div id="camera-preview-resize" style="position: absolute; top: 0; left: 0; width: 20px; height: 20px; cursor: nw-resize; z-index: 20; display: flex; align-items: center; justify-content: center;">
                    <svg width="10" height="10" viewBox="0 0 10 10" style="opacity: 0.5;">
                        <path d="M0 10 L10 0 M0 6 L6 0 M0 2 L2 0" stroke="var(--accent-cyan)" stroke-width="1.5" fill="none"/>
                    </svg>
                </div>
                <div style="position: absolute; top: 0; left: 0; right: 0; padding: 4px 8px; padding-left: 24px; background: rgba(0, 0, 0, 0.7); font-size: 10px; color: var(--accent-cyan); display: flex; justify-content: space-between; align-items: center; z-index: 10;">
                    <span>ðŸ“· Camera View</span>
                    <span id="camera-preview-info">35mm â€¢ Full Frame</span>
                </div>
                <canvas id="camera-preview-canvas" style="width: 100%; height: 100%;"></canvas>
                <div style="position: absolute; bottom: 0; left: 0; right: 0; padding: 4px 8px; background: rgba(0, 0, 0, 0.7); font-size: 9px; color: var(--text-secondary); display: flex; justify-content: space-between;">
                    <span id="camera-preview-fov">H: 54.4Â° V: 37.8Â°</span>
                    <span id="camera-preview-res">1920Ã—1080</span>
                </div>
            </div>
            <div class="viewport-overlay">
                <div class="grid-lines"></div>
                <div class="viewport-info">
                    <div class="info-badge">Drag to rotate â€¢ Scroll to zoom â€¢ WASD to move â€¢ G=translate R=rotate L=space P=pilot</div>
                </div>
                <div class="viewport-controls">
                    <button class="view-btn" id="view-front" title="Front View">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <rect x="3" y="3" width="18" height="18" rx="2"/>
                        </svg>
                    </button>
                    <button class="view-btn" id="view-side" title="Side View">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M12 3v18M3 12h18"/>
                        </svg>
                    </button>
                    <button class="view-btn" id="view-top" title="Top View">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <circle cx="12" cy="12" r="9"/>
                            <circle cx="12" cy="12" r="3"/>
                        </svg>
                    </button>
                    <button class="view-btn" id="view-reset" title="Reset View">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/>
                            <path d="M3 3v5h5"/>
                        </svg>
                    </button>
                    <button class="view-btn active" id="toggle-grid" title="Toggle Grid">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M3 3h18v18H3zM3 9h18M3 15h18M9 3v18M15 3v18"/>
                        </svg>
                    </button>
                </div>
                <div class="gizmo-controls">
                    <button class="gizmo-mode-btn translate" id="gizmo-translate" title="Translate Mode (G)">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M5 9l-3 3 3 3M9 5l3-3 3 3M15 19l-3 3-3-3M19 9l3 3-3 3M2 12h20M12 2v20"/>
                        </svg>
                    </button>
                    <button class="gizmo-mode-btn rotate" id="gizmo-rotate" title="Rotate Mode (R)">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M21 12a9 9 0 1 1-9-9c2.52 0 4.93 1 6.74 2.74L21 8"/>
                            <path d="M21 3v5h-5"/>
                        </svg>
                    </button>
                    <button class="gizmo-mode-btn space world" id="gizmo-space" title="World Space (L to toggle)">W</button>
                    <div class="gizmo-divider"></div>
                    <button class="gizmo-mode-btn pilot" id="gizmo-pilot" title="Pilot Camera View (P)">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"/>
                            <circle cx="12" cy="13" r="4"/>
                        </svg>
                    </button>
                </div>
                <div class="selection-indicator" id="selection-indicator">
                    Selected: <span class="selected-name">None</span>
                </div>
                <div class="pilot-info" id="pilot-info">
                    ðŸŽ¥ PILOT MODE â€” WASD: Move â€¢ Mouse: Look â€¢ QE: Up/Down â€¢ Scroll: Speed â€¢ ESC: Exit
                </div>
            </div>
        </main>
    </div>

    <script>
        let scene, camera, renderer, ledWallGroup, frameGroup;
        let animationEnabled = false;
        let showFrame = false;
        let wireframeEnabled = false;
        let ledSimEnabled = false;
        let meshMode = 'combined';
        let animationTime = 0;
        
        // Grid
        let gridHelper = null;
        let showGrid = true;
        
        // Safe distance visualization
        let safeDistanceEnabled = false;
        let safeDistanceMesh = null;
        
        // Panel ID settings
        let panelIdsEnabled = false;
        let panelBorderThickness = 8;
        let panelFontSize = 0; // 0 = auto

        // Camera Frustum Preview settings
        let cameraPreviewEnabled = false;
        let previewCameraGroup = null;
        let frustumHelper = null;
        let frustumOutline = null;
        let wallIntersectionPlane = null;
        
        // Filmback presets (width x height in mm)
        const filmbackPresets = {
            'full-frame': { name: 'Full Frame (36Ã—24mm)', width: 36, height: 24 },
            'super35': { name: 'Super 35 (24.89Ã—18.66mm)', width: 24.89, height: 18.66 },
            'arri-lf': { name: 'ARRI LF (36.70Ã—25.54mm)', width: 36.70, height: 25.54 },
            'arri-alexa': { name: 'ARRI Alexa (28.17Ã—18.13mm)', width: 28.17, height: 18.13 },
            'red-v-raptor': { name: 'RED V-RAPTOR (40.96Ã—21.60mm)', width: 40.96, height: 21.60 },
            'red-komodo': { name: 'RED KOMODO (27.03Ã—14.26mm)', width: 27.03, height: 14.26 },
            'sony-venice': { name: 'Sony VENICE (36Ã—24mm)', width: 36, height: 24 },
            'bmpcc-6k': { name: 'BMPCC 6K (23.10Ã—12.99mm)', width: 23.10, height: 12.99 },
            'aps-c': { name: 'APS-C (23.6Ã—15.6mm)', width: 23.6, height: 15.6 },
            'mft': { name: 'Micro 4/3 (17.3Ã—13mm)', width: 17.3, height: 13 },
            'custom': { name: 'Custom', width: 36, height: 24 }
        };
        
        let cameraSettings = {
            filmback: 'full-frame',
            filmbackWidth: 36,
            filmbackHeight: 24,
            focalLength: 35,
            posX: 0,
            posY: 1.5, // meters from ground
            posZ: 5,   // meters from wall
            rotX: 0,   // tilt (degrees)
            rotY: 0,   // pan (degrees)
            rotZ: 0    // roll (degrees)
        };

        // Scene Props
        let personMesh = null;
        let carMesh = null;
        let showPerson = false;
        let showCar = false;
        
        let personSettings = {
            posX: 2,
            posZ: 2,
            rotY: 0,
            scale: 1
        };
        
        let carSettings = {
            posX: 4,
            posZ: 3,
            rotY: 0,
            scale: 1
        };

        // Preview Camera (for camera view window)
        let previewCamera = null;
        let previewRenderer = null;

        // Gizmo System
        let gizmoMode = null; // 'translate', 'rotate', or null
        let gizmoSpace = 'world'; // 'world' or 'local'
        let selectedObject = null; // 'camera', 'person', 'car', or null
        let gizmoGroup = null;
        let gizmoHandles = {};
        let isDraggingGizmo = false;
        let activeGizmoAxis = null;
        let hoveredGizmoAxis = null;
        let dragStartPoint = new THREE.Vector3();
        let dragPlane = new THREE.Plane();
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2();
        let pilotMode = false;
        let savedCameraState = null;
        let cameraBodyMesh = null; // Reference to camera body for selection (not frustum)
        
        // Pilot mode controls
        let pilotMoveSpeed = 0.05;
        let isPilotLooking = false;
        let pilotLastMouse = { x: 0, y: 0 };

        const sectionColors = [
            '#00f0ff', '#ff00aa', '#00ff66', '#ff6b35',
            '#ffdd00', '#aa66ff', '#66ffaa', '#ff6666'
        ];
        
        const panelBorderColors = ['#ff0000', '#00ff00', '#0000ff']; // R, G, B cycle

        // Panel ID customization
        let panelIdFontColor = '#ffffff';
        let sectionLabelEnabled = true;
        let sectionLabelFontSize = 0; // 0 = auto
        let sectionLabelColor = '#888888';

        let wallSections = [{
            id: 0,
            name: 'Wall 1',
            panelCols: 5,
            panelRows: 3,
            panelWidth: 500,
            panelHeight: 500,
            ledX: 32,
            ledY: 32,
            curveIntensity: 0,
            angleOffset: 0, // degrees - rotation offset before this section
            color: '#00f0ff'
        }];

        let nextSectionId = 1;

        function init() {
            const canvas = document.getElementById('three-canvas');
            const container = canvas.parentElement;

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0a0f);

            camera = new THREE.PerspectiveCamera(50, container.clientWidth / container.clientHeight, 0.1, 1000);
            camera.position.set(0, 0, 8);

            renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

            scene.add(new THREE.AmbientLight(0xffffff, 0.3));
            const pointLight = new THREE.PointLight(0xffffff, 0.8);
            pointLight.position.set(5, 5, 10);
            scene.add(pointLight);

            // Floor grid - larger area, on Y=0 plane
            gridHelper = new THREE.GridHelper(50, 50, 0x2a2a3a, 0x1a1a24);
            gridHelper.position.set(12.5, 0, 12.5); // Offset to cover area in front of wall
            scene.add(gridHelper);
            scene.add(new THREE.AxesHelper(0.5));

            createLEDWall();
            setupControls();
            window.addEventListener('resize', onResize);
            animate();
        }

        function createLEDWall() {
            if (ledWallGroup) {
                scene.remove(ledWallGroup);
                ledWallGroup.traverse((child) => {
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) {
                        if (Array.isArray(child.material)) child.material.forEach(m => m.dispose());
                        else child.material.dispose();
                    }
                });
            }
            if (frameGroup) {
                scene.remove(frameGroup);
                frameGroup.traverse((child) => {
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) child.material.dispose();
                });
            }

            ledWallGroup = new THREE.Group();
            frameGroup = new THREE.Group();

            const scale = 0.001;
            let allSectionsData = [];
            
            // Track cumulative position and angle across sections
            let currentX = 0;
            let currentZ = 0;
            let currentAngle = 0; // This is the direction the wall is "facing" (perpendicular to panel surface)

            wallSections.forEach((section, sectionIndex) => {
                const panelW = section.panelWidth * scale;
                const panelH = section.panelHeight * scale;
                // Curve angle is signed: positive = concave (curves toward viewer), negative = convex (curves away)
                const curveAngleRad = (section.curveIntensity * Math.PI) / 180;
                const isFlat = section.curveIntensity === 0;
                
                // Apply section angle offset before building this section
                const angleOffsetRad = ((section.angleOffset || 0) * Math.PI) / 180;
                currentAngle += angleOffsetRad;

                const edgePositions = [];
                const panelData = [];

                // First edge starts at current position with current angle
                edgePositions.push({ x: currentX, z: currentZ, angle: currentAngle });

                for (let col = 0; col < section.panelCols; col++) {
                    // Apply curve angle (rotation around Y axis)
                    // Positive curve = rotate left (increase angle), negative = rotate right (decrease angle)
                    if (!isFlat) {
                        currentAngle += curveAngleRad;
                    }

                    // Move perpendicular to the current facing direction
                    // If angle = 0, we're facing +Z, so we move along +X
                    // The panel edge moves in direction perpendicular to facing
                    const moveDirection = currentAngle; // Direction to move along the panel edge
                    
                    currentX += panelW * Math.cos(moveDirection);
                    currentZ += panelW * Math.sin(moveDirection);

                    edgePositions.push({ x: currentX, z: currentZ, angle: currentAngle });
                }

                // Calculate panel centers
                for (let row = 0; row < section.panelRows; row++) {
                    const y = row * panelH;

                    for (let col = 0; col < section.panelCols; col++) {
                        const leftEdge = edgePositions[col];
                        const rightEdge = edgePositions[col + 1];

                        const centerX = (leftEdge.x + rightEdge.x) / 2;
                        const centerZ = (leftEdge.z + rightEdge.z) / 2;
                        const centerY = y + panelH / 2;

                        const dx = rightEdge.x - leftEdge.x;
                        const dz = rightEdge.z - leftEdge.z;
                        const rotY = -Math.atan2(dz, dx);

                        panelData.push({
                            x: centerX, y: centerY, z: centerZ,
                            rotY, col, row, sectionIndex
                        });
                    }
                }

                allSectionsData.push({
                    section, sectionIndex, edgePositions, panelData,
                    panelW, panelH, isFlat
                });
            });

            if (meshMode === 'combined') {
                createCombinedMesh(allSectionsData);
            } else if (meshMode === 'section') {
                createSectionMeshes(allSectionsData);
            } else {
                createIndividualPanels(allSectionsData);
            }

            if (showFrame) {
                allSectionsData.forEach(({ panelData, panelW, panelH }) => {
                    panelData.forEach((data) => {
                        const frameGeometry = new THREE.EdgesGeometry(new THREE.BoxGeometry(panelW, panelH, 0.02));
                        const frame = new THREE.LineSegments(frameGeometry, new THREE.LineBasicMaterial({ color: 0x4a4a5a }));
                        frame.position.set(data.x, data.y, data.z);
                        frame.rotation.y = data.rotY;
                        frameGroup.add(frame);
                    });
                });
            }

            scene.add(ledWallGroup);
            if (showFrame) scene.add(frameGroup);

            updateStats();
            updateCameraPosition();
            if (cameraPreviewEnabled) updateCameraFrustum();
        }

        function createCombinedMesh(allSectionsData) {
            const vertPositions = [];
            const vertNormals = [];
            const vertUvs = [];
            const indices = [];
            let vertexOffset = 0;

            let totalLedX = 0, totalLedY = 0;
            wallSections.forEach(s => {
                totalLedX += s.panelCols * s.ledX;
                totalLedY = Math.max(totalLedY, s.panelRows * s.ledY);
            });

            let uvOffsetX = 0;

            allSectionsData.forEach(({ section, edgePositions, panelW, panelH, isFlat }) => {
                const sectionLedX = section.panelCols * section.ledX;
                const uvWidth = sectionLedX / totalLedX;

                for (let row = 0; row <= section.panelRows; row++) {
                    const y = row * panelH;
                    for (let col = 0; col <= section.panelCols; col++) {
                        const edge = edgePositions[col];
                        vertPositions.push(edge.x, y, edge.z);

                        // Normal points perpendicular to panel surface (outward toward viewer)
                        // At angle=0, normal is (0, 0, 1). As angle increases, normal rotates.
                        // Normal direction is 90 degrees from the edge direction
                        let nx, nz;
                        if (col < section.panelCols) {
                            const nextEdge = edgePositions[col + 1];
                            const dx = nextEdge.x - edge.x;
                            const dz = nextEdge.z - edge.z;
                            const len = Math.sqrt(dx * dx + dz * dz);
                            // Normal is perpendicular to edge direction, pointing outward
                            nx = -dz / len;
                            nz = dx / len;
                        } else {
                            // Last edge - use previous edge's direction
                            const prevEdge = edgePositions[col - 1];
                            const dx = edge.x - prevEdge.x;
                            const dz = edge.z - prevEdge.z;
                            const len = Math.sqrt(dx * dx + dz * dz);
                            nx = -dz / len;
                            nz = dx / len;
                        }
                        vertNormals.push(nx, 0, nz);

                        vertUvs.push(uvOffsetX + (col / section.panelCols) * uvWidth, row / section.panelRows);
                    }
                }

                const vertsPerRow = section.panelCols + 1;
                for (let row = 0; row < section.panelRows; row++) {
                    for (let col = 0; col < section.panelCols; col++) {
                        const bl = vertexOffset + row * vertsPerRow + col;
                        const br = bl + 1;
                        const tl = vertexOffset + (row + 1) * vertsPerRow + col;
                        const tr = tl + 1;
                        indices.push(bl, tl, tr, bl, tr, br);
                    }
                }

                vertexOffset += (section.panelCols + 1) * (section.panelRows + 1);
                uvOffsetX += uvWidth;
            });

            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertPositions, 3));
            geometry.setAttribute('normal', new THREE.Float32BufferAttribute(vertNormals, 3));
            geometry.setAttribute('uv', new THREE.Float32BufferAttribute(vertUvs, 2));
            geometry.setIndex(indices);

            // For combined mesh, use vertex colors to support multiple section colors
            const colors = [];
            allSectionsData.forEach(({ section }) => {
                const color = new THREE.Color(section.color);
                for (let row = 0; row <= section.panelRows; row++) {
                    for (let col = 0; col <= section.panelCols; col++) {
                        colors.push(color.r, color.g, color.b);
                    }
                }
            });
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

            let material;
            if (panelIdsEnabled) {
                // Create combined panel ID texture
                const combinedCanvas = createCombinedPanelIdCanvas();
                const texture = new THREE.CanvasTexture(combinedCanvas);
                texture.needsUpdate = true;
                material = new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide, wireframe: wireframeEnabled });
            } else if (ledSimEnabled) {
                material = new THREE.MeshBasicMaterial({ map: createLEDTexture(totalLedX, totalLedY, wallSections[0].color), side: THREE.DoubleSide, wireframe: wireframeEnabled });
            } else {
                material = new THREE.MeshBasicMaterial({ vertexColors: true, side: THREE.DoubleSide, wireframe: wireframeEnabled });
            }

            ledWallGroup.add(new THREE.Mesh(geometry, material));
        }

        function createCombinedPanelIdCanvas() {
            let totalLedX = 0, totalLedY = 0;
            wallSections.forEach(s => {
                totalLedX += s.panelCols * s.ledX;
                totalLedY = Math.max(totalLedY, s.panelRows * s.ledY);
            });

            const scale = Math.max(1, Math.min(4, Math.floor(4096 / Math.max(totalLedX, totalLedY))));
            const canvas = document.createElement('canvas');
            canvas.width = totalLedX * scale;
            canvas.height = totalLedY * scale;
            const ctx = canvas.getContext('2d');

            ctx.fillStyle = '#0a0a0f';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            let xOffset = 0;
            let cumulativeCol = 0;
            wallSections.forEach((section, sectionIndex) => {
                const sectionCanvas = createSectionPanelIdCanvas(section, sectionIndex, scale, cumulativeCol);
                // Draw section canvas at correct position, accounting for different heights
                const yOffset = (totalLedY - section.panelRows * section.ledY) * scale;
                ctx.drawImage(sectionCanvas, xOffset * scale, yOffset);
                xOffset += section.panelCols * section.ledX;
                cumulativeCol += section.panelCols;
            });

            return canvas;
        }

        function createSectionMeshes(allSectionsData) {
            let cumulativeCol = 0;
            allSectionsData.forEach(({ section, sectionIndex, edgePositions, panelW, panelH, isFlat }) => {
                const vertPositions = [], vertNormals = [], vertUvs = [], indices = [];
                const sectionColor = new THREE.Color(section.color);

                for (let row = 0; row <= section.panelRows; row++) {
                    const y = row * panelH;
                    for (let col = 0; col <= section.panelCols; col++) {
                        const edge = edgePositions[col];
                        vertPositions.push(edge.x, y, edge.z);
                        
                        // Calculate normal from edge direction
                        let nx, nz;
                        if (col < section.panelCols) {
                            const nextEdge = edgePositions[col + 1];
                            const dx = nextEdge.x - edge.x;
                            const dz = nextEdge.z - edge.z;
                            const len = Math.sqrt(dx * dx + dz * dz);
                            nx = -dz / len;
                            nz = dx / len;
                        } else {
                            const prevEdge = edgePositions[col - 1];
                            const dx = edge.x - prevEdge.x;
                            const dz = edge.z - prevEdge.z;
                            const len = Math.sqrt(dx * dx + dz * dz);
                            nx = -dz / len;
                            nz = dx / len;
                        }
                        vertNormals.push(nx, 0, nz);
                        vertUvs.push(col / section.panelCols, row / section.panelRows);
                    }
                }

                const vertsPerRow = section.panelCols + 1;
                for (let row = 0; row < section.panelRows; row++) {
                    for (let col = 0; col < section.panelCols; col++) {
                        const bl = row * vertsPerRow + col, br = bl + 1;
                        const tl = (row + 1) * vertsPerRow + col, tr = tl + 1;
                        indices.push(bl, tl, tr, bl, tr, br);
                    }
                }

                const geometry = new THREE.BufferGeometry();
                geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertPositions, 3));
                geometry.setAttribute('normal', new THREE.Float32BufferAttribute(vertNormals, 3));
                geometry.setAttribute('uv', new THREE.Float32BufferAttribute(vertUvs, 2));
                geometry.setIndex(indices);

                let material;
                if (panelIdsEnabled) {
                    const panelIdCanvas = createSectionPanelIdCanvas(section, sectionIndex, null, cumulativeCol);
                    const texture = new THREE.CanvasTexture(panelIdCanvas);
                    texture.needsUpdate = true;
                    material = new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide, wireframe: wireframeEnabled });
                } else if (ledSimEnabled) {
                    material = new THREE.MeshBasicMaterial({ map: createLEDTexture(section.panelCols * section.ledX, section.panelRows * section.ledY, section.color), side: THREE.DoubleSide, wireframe: wireframeEnabled });
                } else {
                    material = new THREE.MeshBasicMaterial({ color: sectionColor, side: THREE.DoubleSide, wireframe: wireframeEnabled });
                }

                ledWallGroup.add(new THREE.Mesh(geometry, material));
                cumulativeCol += section.panelCols;
            });
        }

        function createIndividualPanels(allSectionsData) {
            let cumulativeCol = 0;
            allSectionsData.forEach(({ section, sectionIndex, panelData, panelW, panelH }) => {
                const sectionColor = new THREE.Color(section.color);
                
                panelData.forEach((data) => {
                    const geometry = new THREE.PlaneGeometry(panelW, panelH);
                    let material;
                    
                    if (panelIdsEnabled) {
                        // Use cumulative column for sequential labeling across all sections
                        const { texture } = createPanelIdTexture(cumulativeCol + data.col, data.row, sectionIndex, section.ledX, section.ledY, section);
                        material = new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide, wireframe: wireframeEnabled });
                    } else if (ledSimEnabled) {
                        material = new THREE.MeshBasicMaterial({ map: createLEDTexture(section.ledX, section.ledY, section.color), side: THREE.DoubleSide, wireframe: wireframeEnabled });
                    } else {
                        material = new THREE.MeshBasicMaterial({ color: sectionColor, side: THREE.DoubleSide, wireframe: wireframeEnabled });
                    }

                    const panel = new THREE.Mesh(geometry, material);
                    panel.position.set(data.x, data.y, data.z);
                    panel.rotation.y = data.rotY;
                    ledWallGroup.add(panel);
                });
                cumulativeCol += section.panelCols;
            });
        }

        function createLEDTexture(ledX, ledY, color) {
            const ledColor = new THREE.Color(color);
            const canvas = document.createElement('canvas');
            const maxDim = 4096;
            const pixelSize = Math.max(4, Math.min(16, Math.floor(maxDim / Math.max(ledX, ledY))));
            canvas.width = Math.min(maxDim, ledX * pixelSize);
            canvas.height = Math.min(maxDim, ledY * pixelSize);
            const ctx = canvas.getContext('2d');

            ctx.fillStyle = '#0a0a0f';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const pixelW = canvas.width / ledX, pixelH = canvas.height / ledY;
            const ledRadius = Math.min(pixelW, pixelH) * 0.35;

            for (let y = 0; y < ledY; y++) {
                for (let x = 0; x < ledX; x++) {
                    const cx = (x + 0.5) * pixelW, cy = (y + 0.5) * pixelH;

                    const gradient = ctx.createRadialGradient(cx, cy, 0, cx, cy, ledRadius * 1.5);
                    gradient.addColorStop(0, `rgba(${ledColor.r * 255}, ${ledColor.g * 255}, ${ledColor.b * 255}, 1)`);
                    gradient.addColorStop(0.5, `rgba(${ledColor.r * 255}, ${ledColor.g * 255}, ${ledColor.b * 255}, 0.5)`);
                    gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(cx, cy, ledRadius * 1.5, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.fillStyle = `rgb(${ledColor.r * 255}, ${ledColor.g * 255}, ${ledColor.b * 255})`;
                    ctx.beginPath();
                    ctx.arc(cx, cy, ledRadius * 0.7, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;
            return texture;
        }

        function getColumnLabel(index) {
            let label = '';
            let idx = index;
            do {
                label = String.fromCharCode(65 + (idx % 26)) + label;
                idx = Math.floor(idx / 26) - 1;
            } while (idx >= 0);
            return label;
        }

        function createPanelIdTexture(col, row, sectionIndex, ledX, ledY, section) {
            const canvas = document.createElement('canvas');
            const scale = Math.max(4, Math.min(16, Math.floor(4096 / Math.max(ledX, ledY))));
            canvas.width = ledX * scale;
            canvas.height = ledY * scale;
            const ctx = canvas.getContext('2d');

            // Background
            ctx.fillStyle = '#0a0a0f';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Border with RGB cycling based on (col + row) % 3
            const borderColorIndex = (col + row) % 3;
            const borderColor = panelBorderColors[borderColorIndex];
            const borderThickness = panelBorderThickness * scale / 4;
            
            ctx.strokeStyle = borderColor;
            ctx.lineWidth = borderThickness;
            ctx.strokeRect(borderThickness / 2, borderThickness / 2, canvas.width - borderThickness, canvas.height - borderThickness);

            // Label
            const colLabel = getColumnLabel(col);
            const rowLabel = (row + 1).toString();
            const label = `${colLabel}${rowLabel}`;

            // Font size: auto or fixed
            let fontSize = panelFontSize * scale / 4;
            if (fontSize === 0) {
                // Auto size based on canvas dimensions
                fontSize = Math.min(canvas.width, canvas.height) * 0.4;
            }

            ctx.fillStyle = panelIdFontColor;
            ctx.font = `bold ${fontSize}px 'JetBrains Mono', monospace`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(label, canvas.width / 2, canvas.height / 2);

            // Section name indicator (small text at bottom) if enabled
            if (sectionLabelEnabled && section && section.name) {
                const sectionFontSize = fontSize * 0.25;
                ctx.font = `${sectionFontSize}px 'JetBrains Mono', monospace`;
                ctx.fillStyle = sectionLabelColor;
                ctx.fillText(section.name, canvas.width / 2, canvas.height - borderThickness - sectionFontSize);
            }

            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;
            return { texture, canvas };
        }

        function createSectionPanelIdCanvas(section, sectionIndex, overrideScale, startCol = 0) {
            // Create a single canvas for the entire section with all panel IDs
            const canvasWidth = section.panelCols * section.ledX;
            const canvasHeight = section.panelRows * section.ledY;
            const scale = overrideScale || Math.max(1, Math.min(4, Math.floor(4096 / Math.max(canvasWidth, canvasHeight))));
            
            const canvas = document.createElement('canvas');
            canvas.width = canvasWidth * scale;
            canvas.height = canvasHeight * scale;
            const ctx = canvas.getContext('2d');

            // Background
            ctx.fillStyle = '#0a0a0f';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const panelW = section.ledX * scale;
            const panelH = section.ledY * scale;
            const borderThickness = panelBorderThickness * scale / 4;

            for (let row = 0; row < section.panelRows; row++) {
                for (let col = 0; col < section.panelCols; col++) {
                    const x = col * panelW;
                    const y = (section.panelRows - 1 - row) * panelH; // Flip Y for texture coords

                    // Border with RGB cycling (use cumulative column for consistent pattern)
                    const borderColorIndex = ((startCol + col) + row) % 3;
                    ctx.strokeStyle = panelBorderColors[borderColorIndex];
                    ctx.lineWidth = borderThickness;
                    ctx.strokeRect(x + borderThickness / 2, y + borderThickness / 2, panelW - borderThickness, panelH - borderThickness);

                    // Label with cumulative column numbering
                    const colLabel = getColumnLabel(startCol + col);
                    const label = `${colLabel}${row + 1}`;

                    let fontSize = panelFontSize * scale / 4;
                    if (fontSize === 0) {
                        fontSize = Math.min(panelW, panelH) * 0.35;
                    }

                    ctx.fillStyle = panelIdFontColor;
                    ctx.font = `bold ${fontSize}px 'JetBrains Mono', monospace`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(label, x + panelW / 2, y + panelH / 2);
                }
            }

            // Draw section name in center if enabled
            if (sectionLabelEnabled && section.name) {
                let sectionFontSize = sectionLabelFontSize * scale / 4;
                if (sectionFontSize === 0) {
                    sectionFontSize = Math.min(canvas.width, canvas.height) * 0.15;
                }
                
                ctx.fillStyle = sectionLabelColor;
                ctx.font = `bold ${sectionFontSize}px 'Outfit', sans-serif`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.globalAlpha = 0.6;
                ctx.fillText(section.name, canvas.width / 2, canvas.height / 2);
                ctx.globalAlpha = 1.0;
            }

            return canvas;
        }

        function updateStats() {
            let totalPixels = 0, totalPanels = 0, totalArc = 0;
            wallSections.forEach(s => {
                totalPixels += s.panelCols * s.panelRows * s.ledX * s.ledY;
                totalPanels += s.panelCols * s.panelRows;
                totalArc += s.panelCols * Math.abs(s.curveIntensity);
            });
            document.getElementById('total-pixels').textContent = totalPixels.toLocaleString();
            document.getElementById('total-panels').textContent = totalPanels;
            document.getElementById('total-sections').textContent = wallSections.length;
            document.getElementById('total-arc').textContent = `${totalArc.toFixed(1)}Â°`;
        }

        // Camera Frustum Preview Functions
        function createCameraPreview() {
            if (previewCameraGroup) {
                scene.remove(previewCameraGroup);
                previewCameraGroup.traverse((child) => {
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) child.material.dispose();
                });
            }

            previewCameraGroup = new THREE.Group();

            // Create camera body (simple box representation) - positioned behind the camera view point
            const bodyGeom = new THREE.BoxGeometry(0.15, 0.1, 0.2);
            const bodyMat = new THREE.MeshBasicMaterial({ color: 0xff6600, transparent: true, opacity: 0.8 });
            cameraBodyMesh = new THREE.Mesh(bodyGeom, bodyMat);
            cameraBodyMesh.position.z = 0.15; // Move body behind the camera origin so it doesn't block view
            previewCameraGroup.add(cameraBodyMesh);

            // Create frustum wireframe
            updateFrustumGeometry();

            scene.add(previewCameraGroup);
            updateCameraPreviewTransform();
        }

        function updateFrustumGeometry() {
            // Remove old frustum
            if (frustumHelper) {
                previewCameraGroup.remove(frustumHelper);
                frustumHelper.geometry.dispose();
                frustumHelper.material.dispose();
            }
            if (frustumOutline) {
                previewCameraGroup.remove(frustumOutline);
                frustumOutline.geometry.dispose();
                frustumOutline.material.dispose();
            }
            if (wallIntersectionPlane) {
                previewCameraGroup.remove(wallIntersectionPlane);
                wallIntersectionPlane.geometry.dispose();
                wallIntersectionPlane.material.dispose();
            }

            // Calculate FOV from filmback and focal length
            const hFov = 2 * Math.atan(cameraSettings.filmbackWidth / (2 * cameraSettings.focalLength));
            const vFov = 2 * Math.atan(cameraSettings.filmbackHeight / (2 * cameraSettings.focalLength));
            
            // Update UI with FOV values
            document.getElementById('camera-hfov').textContent = `${(hFov * 180 / Math.PI).toFixed(1)}Â°`;
            document.getElementById('camera-vfov').textContent = `${(vFov * 180 / Math.PI).toFixed(1)}Â°`;
            document.getElementById('camera-aspect').textContent = `${(cameraSettings.filmbackWidth / cameraSettings.filmbackHeight).toFixed(2)}:1`;

            // Frustum depth (how far to draw it)
            const frustumDepth = 15; // meters
            const nearPlane = 0.2;

            // Calculate frustum corners at near and far planes
            const nearHalfW = Math.tan(hFov / 2) * nearPlane;
            const nearHalfH = Math.tan(vFov / 2) * nearPlane;
            const farHalfW = Math.tan(hFov / 2) * frustumDepth;
            const farHalfH = Math.tan(vFov / 2) * frustumDepth;

            // Create frustum lines
            const frustumVertices = [];
            
            // Near plane corners (looking down -Z)
            const nearTL = [-nearHalfW, nearHalfH, -nearPlane];
            const nearTR = [nearHalfW, nearHalfH, -nearPlane];
            const nearBL = [-nearHalfW, -nearHalfH, -nearPlane];
            const nearBR = [nearHalfW, -nearHalfH, -nearPlane];
            
            // Far plane corners
            const farTL = [-farHalfW, farHalfH, -frustumDepth];
            const farTR = [farHalfW, farHalfH, -frustumDepth];
            const farBL = [-farHalfW, -farHalfH, -frustumDepth];
            const farBR = [farHalfW, -farHalfH, -frustumDepth];

            // Near plane rectangle
            frustumVertices.push(...nearTL, ...nearTR, ...nearTR, ...nearBR, ...nearBR, ...nearBL, ...nearBL, ...nearTL);
            // Far plane rectangle
            frustumVertices.push(...farTL, ...farTR, ...farTR, ...farBR, ...farBR, ...farBL, ...farBL, ...farTL);
            // Connecting lines
            frustumVertices.push(...nearTL, ...farTL, ...nearTR, ...farTR, ...nearBL, ...farBL, ...nearBR, ...farBR);

            const frustumGeom = new THREE.BufferGeometry();
            frustumGeom.setAttribute('position', new THREE.Float32BufferAttribute(frustumVertices, 3));
            frustumHelper = new THREE.LineSegments(frustumGeom, new THREE.LineBasicMaterial({ color: 0xffaa00, transparent: true, opacity: 0.7 }));
            previewCameraGroup.add(frustumHelper);

            // Create semi-transparent frustum fill
            const fillGeom = new THREE.BufferGeometry();
            const fillVertices = new Float32Array([
                // Near plane
                ...nearTL, ...nearTR, ...nearBR, ...nearTL, ...nearBR, ...nearBL,
                // Left side
                ...nearTL, ...nearBL, ...farBL, ...nearTL, ...farBL, ...farTL,
                // Right side
                ...nearTR, ...farTR, ...farBR, ...nearTR, ...farBR, ...nearBR,
                // Top side
                ...nearTL, ...farTL, ...farTR, ...nearTL, ...farTR, ...nearTR,
                // Bottom side
                ...nearBL, ...nearBR, ...farBR, ...nearBL, ...farBR, ...farBL
            ]);
            fillGeom.setAttribute('position', new THREE.BufferAttribute(fillVertices, 3));
            frustumOutline = new THREE.Mesh(fillGeom, new THREE.MeshBasicMaterial({ 
                color: 0xffaa00, transparent: true, opacity: 0.08, side: THREE.DoubleSide, depthWrite: false 
            }));
            previewCameraGroup.add(frustumOutline);
        }

        function updateCameraPreviewTransform() {
            if (!previewCameraGroup) return;

            // Position camera (Z is distance from wall, so we position it at +Z)
            previewCameraGroup.position.set(
                cameraSettings.posX,
                cameraSettings.posY,
                cameraSettings.posZ
            );

            // Apply rotations using YXZ order to avoid gimbal lock
            // Pan (Y) first, then Tilt (X), then Roll (Z)
            const tilt = cameraSettings.rotX * Math.PI / 180;
            const pan = cameraSettings.rotY * Math.PI / 180;
            const roll = cameraSettings.rotZ * Math.PI / 180;
            
            previewCameraGroup.rotation.order = 'YXZ';
            previewCameraGroup.rotation.set(tilt, pan, roll);
        }

        function updateCameraFrustum() {
            if (!cameraPreviewEnabled) return;
            
            if (!previewCameraGroup) {
                createCameraPreview();
            }

            updateFrustumGeometry();
            updateCameraPreviewTransform();
            calculateFrustumIntersection();
            updatePreviewCamera();
            updateSafeDistance();
            updatePilotView();
            
            // Update gizmo position if camera is selected
            if (selectedObject === 'camera') {
                updateGizmoPosition();
            }
        }

        function calculateFrustumIntersection() {
            // Calculate where frustum intersects the wall plane (Z = 0)
            const hFov = 2 * Math.atan(cameraSettings.filmbackWidth / (2 * cameraSettings.focalLength));
            const vFov = 2 * Math.atan(cameraSettings.filmbackHeight / (2 * cameraSettings.focalLength));
            
            // Distance from camera to wall plane
            const distToWall = cameraSettings.posZ;
            
            // Frame size at wall distance (simplified, assumes camera pointing at wall)
            const frameWidth = 2 * Math.tan(hFov / 2) * distToWall;
            const frameHeight = 2 * Math.tan(vFov / 2) * distToWall;
            
            // Update UI
            document.getElementById('frustum-width').textContent = `${frameWidth.toFixed(2)}m`;
            document.getElementById('frustum-height').textContent = `${frameHeight.toFixed(2)}m`;

            // Calculate wall dimensions
            const scale = 0.001;
            let totalWallWidth = 0, maxWallHeight = 0;
            wallSections.forEach(s => {
                totalWallWidth += s.panelCols * s.panelWidth * scale;
                maxWallHeight = Math.max(maxWallHeight, s.panelRows * s.panelHeight * scale);
            });

            // Check if frame fits within wall
            const fitsWidth = frameWidth <= totalWallWidth;
            const fitsHeight = frameHeight <= maxWallHeight;
            
            // Calculate center offset
            const camCenterX = cameraSettings.posX;
            const camCenterY = cameraSettings.posY;
            const wallCenterX = totalWallWidth / 2;
            const wallCenterY = maxWallHeight / 2;
            
            // Check if frame is within wall bounds considering position
            const frameLeft = camCenterX - frameWidth / 2;
            const frameRight = camCenterX + frameWidth / 2;
            const frameBottom = camCenterY - frameHeight / 2;
            const frameTop = camCenterY + frameHeight / 2;
            
            const withinBounds = frameLeft >= 0 && frameRight <= totalWallWidth && 
                                frameBottom >= 0 && frameTop <= maxWallHeight;

            // Update status
            const statusEl = document.getElementById('frustum-status-text');
            if (withinBounds) {
                statusEl.textContent = 'Within bounds';
                statusEl.style.color = '#00ff66';
            } else if (fitsWidth && fitsHeight) {
                statusEl.textContent = 'Off-center';
                statusEl.style.color = '#ffaa00';
            } else {
                statusEl.textContent = 'Exceeds wall';
                statusEl.style.color = '#ff4444';
            }

            // Calculate max safe distance (beyond this, frame exceeds wall)
            // Use MIN because we're limited by whichever dimension we'd exceed first
            const maxSafeDistWidth = totalWallWidth / (2 * Math.tan(hFov / 2));
            const maxSafeDistHeight = maxWallHeight / (2 * Math.tan(vFov / 2));
            const safeDistance = Math.min(maxSafeDistWidth, maxSafeDistHeight);
            
            document.getElementById('safe-distance').textContent = `â‰¤ ${safeDistance.toFixed(2)}m`;
        }

        function removeCameraPreview() {
            if (previewCameraGroup) {
                scene.remove(previewCameraGroup);
                previewCameraGroup.traverse((child) => {
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) child.material.dispose();
                });
                previewCameraGroup = null;
                frustumHelper = null;
                frustumOutline = null;
                wallIntersectionPlane = null;
            }
        }

        function resetCameraPosition() {
            // Calculate wall center
            const scale = 0.001;
            let totalWallWidth = 0, maxWallHeight = 0;
            wallSections.forEach(s => {
                totalWallWidth += s.panelCols * s.panelWidth * scale;
                maxWallHeight = Math.max(maxWallHeight, s.panelRows * s.panelHeight * scale);
            });

            cameraSettings.posX = totalWallWidth / 2;
            cameraSettings.posY = maxWallHeight / 2;
            cameraSettings.posZ = 5;
            cameraSettings.rotX = 0;
            cameraSettings.rotY = 0;
            cameraSettings.rotZ = 0;

            // Update UI
            document.getElementById('camera-pos-x').value = cameraSettings.posX.toFixed(1);
            document.getElementById('camera-pos-y').value = cameraSettings.posY.toFixed(1);
            document.getElementById('camera-pos-z').value = cameraSettings.posZ;
            document.getElementById('camera-rot-x').value = cameraSettings.rotX;
            document.getElementById('camera-rot-y').value = cameraSettings.rotY;
            document.getElementById('camera-rot-z').value = cameraSettings.rotZ;

            updateCameraFrustum();
        }

        // Grid toggle
        function toggleGrid() {
            showGrid = !showGrid;
            if (gridHelper) {
                gridHelper.visible = showGrid;
            }
        }

        // Safe Distance 3D Visualization
        function createSafeDistanceMesh() {
            removeSafeDistanceMesh();
            
            if (!cameraPreviewEnabled) return;

            const scale = 0.001;
            const hFov = 2 * Math.atan(cameraSettings.filmbackWidth / (2 * cameraSettings.focalLength));
            const vFov = 2 * Math.atan(cameraSettings.filmbackHeight / (2 * cameraSettings.focalLength));

            safeDistanceMesh = new THREE.Group();

            // Calculate overall wall dimensions for safe distance
            let totalWallWidth = 0;
            let maxWallHeight = 0;
            wallSections.forEach(s => {
                totalWallWidth += s.panelCols * s.panelWidth * scale;
                maxWallHeight = Math.max(maxWallHeight, s.panelRows * s.panelHeight * scale);
            });
            
            // Safe distance = maximum distance where frame still fits within wall
            // Use MIN because we're limited by whichever dimension we'd exceed first
            // Formula: at distance D, frame size = 2 * D * tan(FOV/2)
            // Frame fits when: 2 * D * tan(FOV/2) <= wallDimension
            // So: D <= wallDimension / (2 * tan(FOV/2))
            const maxSafeDistW = totalWallWidth / (2 * Math.tan(hFov / 2));
            const maxSafeDistH = maxWallHeight / (2 * Math.tan(vFov / 2));
            const overallSafeDist = Math.min(maxSafeDistW, maxSafeDistH);

            // Build edge positions matching createLEDWall exactly
            let currentX = 0;
            let currentZ = 0;
            let currentAngle = 0;
            
            const allEdges = []; // Store all edges across all sections (flattened)

            wallSections.forEach((section, sectionIndex) => {
                const panelW = section.panelWidth * scale;
                const panelH = section.panelHeight * scale;
                const curveAngleRad = (section.curveIntensity * Math.PI) / 180;
                const isFlat = section.curveIntensity === 0;
                
                // Apply section angle offset
                const angleOffsetRad = ((section.angleOffset || 0) * Math.PI) / 180;
                currentAngle += angleOffsetRad;

                // Store first edge of section
                if (allEdges.length === 0) {
                    allEdges.push({ x: currentX, z: currentZ, angle: currentAngle });
                }

                for (let col = 0; col < section.panelCols; col++) {
                    if (!isFlat) {
                        currentAngle += curveAngleRad;
                    }

                    const moveDirection = currentAngle;
                    currentX += panelW * Math.cos(moveDirection);
                    currentZ += panelW * Math.sin(moveDirection);

                    allEdges.push({ x: currentX, z: currentZ, angle: currentAngle });
                }
            });

            // Create floor mesh from wall to safe distance
            const vertices = [];
            const indices = [];
            const colors = [];
            let vertexIndex = 0;

            // Also collect points for the curved safe distance line
            const safeLinePoints = [];

            for (let i = 0; i < allEdges.length - 1; i++) {
                const leftEdge = allEdges[i];
                const rightEdge = allEdges[i + 1];

                // Calculate panel facing direction (normal pointing toward camera/+Z for flat)
                const dx = rightEdge.x - leftEdge.x;
                const dz = rightEdge.z - leftEdge.z;
                
                // Normal perpendicular to panel edge, pointing outward (toward viewer)
                const edgeLen = Math.sqrt(dx * dx + dz * dz);
                const normalX = -dz / edgeLen;
                const normalZ = dx / edgeLen;

                // Wall edge points (on floor)
                const wallLeft = { x: leftEdge.x, z: leftEdge.z };
                const wallRight = { x: rightEdge.x, z: rightEdge.z };
                
                // Safe distance points (extend in normal direction using OVERALL safe distance)
                const safeLeft = {
                    x: leftEdge.x + normalX * overallSafeDist,
                    z: leftEdge.z + normalZ * overallSafeDist
                };
                const safeRight = {
                    x: rightEdge.x + normalX * overallSafeDist,
                    z: rightEdge.z + normalZ * overallSafeDist
                };

                // Collect safe line points (use left edge of each panel, plus final right edge)
                if (i === 0) {
                    safeLinePoints.push(safeLeft);
                }
                safeLinePoints.push(safeRight);

                // Add vertices (on floor, Y=0.005 to avoid z-fighting)
                vertices.push(wallLeft.x, 0.005, wallLeft.z);
                vertices.push(wallRight.x, 0.005, wallRight.z);
                vertices.push(safeRight.x, 0.005, safeRight.z);
                vertices.push(safeLeft.x, 0.005, safeLeft.z);

                // Colors - gradient from GREEN (wall/safe) to RED (threshold/danger)
                const wallColor = [0.2, 1, 0.4]; // Green - safe zone near wall
                const thresholdColor = [1, 0.2, 0.2]; // Red - edge of safe zone
                colors.push(...wallColor, ...wallColor, ...thresholdColor, ...thresholdColor);

                // Indices for two triangles
                indices.push(
                    vertexIndex, vertexIndex + 1, vertexIndex + 2,
                    vertexIndex, vertexIndex + 2, vertexIndex + 3
                );
                vertexIndex += 4;
            }

            if (vertices.length > 0) {
                const geometry = new THREE.BufferGeometry();
                geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
                geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
                geometry.setIndex(indices);
                geometry.computeVertexNormals();

                const material = new THREE.MeshBasicMaterial({
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.5,
                    side: THREE.DoubleSide,
                    depthWrite: false
                });

                const mesh = new THREE.Mesh(geometry, material);
                safeDistanceMesh.add(mesh);

                // Draw curved safe distance line following wall shape
                const lineMaterial = new THREE.LineBasicMaterial({ color: 0xff4444, transparent: true, opacity: 0.8, linewidth: 2 });
                const linePositions = [];
                safeLinePoints.forEach(pt => {
                    linePositions.push(pt.x, 0.02, pt.z);
                });
                const lineGeom = new THREE.BufferGeometry();
                lineGeom.setAttribute('position', new THREE.Float32BufferAttribute(linePositions, 3));
                const safeLine = new THREE.Line(lineGeom, lineMaterial);
                safeDistanceMesh.add(safeLine);

                // Find center point of the safe line for label placement
                const midIndex = Math.floor(safeLinePoints.length / 2);
                const labelPos = safeLinePoints[midIndex];

                // Add text sprite for distance label at curve center
                const canvas = document.createElement('canvas');
                canvas.width = 256;
                canvas.height = 64;
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = '#ff4444';
                ctx.font = 'bold 32px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(`Max: ${overallSafeDist.toFixed(2)}m`, 128, 40);
                
                const texture = new THREE.CanvasTexture(canvas);
                const spriteMaterial = new THREE.SpriteMaterial({ map: texture, transparent: true });
                const sprite = new THREE.Sprite(spriteMaterial);
                sprite.position.set(labelPos.x, 0.5, labelPos.z);
                sprite.scale.set(2, 0.5, 1);
                safeDistanceMesh.add(sprite);
            }

            scene.add(safeDistanceMesh);
        }

        function removeSafeDistanceMesh() {
            if (safeDistanceMesh) {
                scene.remove(safeDistanceMesh);
                safeDistanceMesh.traverse((child) => {
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) {
                        if (child.material.map) child.material.map.dispose();
                        child.material.dispose();
                    }
                });
                safeDistanceMesh = null;
            }
        }

        function updateSafeDistance() {
            if (safeDistanceEnabled && cameraPreviewEnabled) {
                createSafeDistanceMesh();
            } else {
                removeSafeDistanceMesh();
            }
        }

        function exportSafeDistanceOBJ() {
            if (!safeDistanceMesh) {
                alert('Enable Safe Distance 3D visualization first');
                return;
            }

            let objContent = '# Safe Distance Floor Mesh\n# Exported from LED Wall Configurator\n\n';
            
            let vertexOffset = 1;
            
            safeDistanceMesh.traverse((child) => {
                if (child.isMesh && child.geometry) {
                    const positions = child.geometry.attributes.position;
                    const indices = child.geometry.index;
                    
                    // Export vertices
                    for (let i = 0; i < positions.count; i++) {
                        const x = positions.getX(i);
                        const y = positions.getY(i);
                        const z = positions.getZ(i);
                        objContent += `v ${x.toFixed(6)} ${y.toFixed(6)} ${z.toFixed(6)}\n`;
                    }
                    
                    objContent += '\n';
                    
                    // Export faces
                    if (indices) {
                        for (let i = 0; i < indices.count; i += 3) {
                            const a = indices.getX(i) + vertexOffset;
                            const b = indices.getX(i + 1) + vertexOffset;
                            const c = indices.getX(i + 2) + vertexOffset;
                            objContent += `f ${a} ${b} ${c}\n`;
                        }
                    }
                    
                    vertexOffset += positions.count;
                }
            });

            const blob = new Blob([objContent], { type: 'text/plain' });
            downloadBlob(blob, 'safe-distance-floor.obj');
        }

        // Scene Props Functions
        function createPersonMesh() {
            if (personMesh) {
                scene.remove(personMesh);
                personMesh.traverse((child) => {
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) child.material.dispose();
                });
            }

            personMesh = new THREE.Group();
            const personMaterial = new THREE.MeshBasicMaterial({ color: 0x4488ff, transparent: true, opacity: 0.85 });
            const darkMaterial = new THREE.MeshBasicMaterial({ color: 0x2244aa, transparent: true, opacity: 0.85 });

            // Legs (two cylinders)
            const legGeom = new THREE.CylinderGeometry(0.08, 0.08, 0.85, 8);
            const leftLeg = new THREE.Mesh(legGeom, darkMaterial);
            leftLeg.position.set(-0.1, 0.425, 0);
            personMesh.add(leftLeg);
            const rightLeg = new THREE.Mesh(legGeom, darkMaterial);
            rightLeg.position.set(0.1, 0.425, 0);
            personMesh.add(rightLeg);

            // Torso (box)
            const torsoGeom = new THREE.BoxGeometry(0.4, 0.55, 0.22);
            const torso = new THREE.Mesh(torsoGeom, personMaterial);
            torso.position.set(0, 1.125, 0);
            personMesh.add(torso);

            // Arms (two cylinders)
            const armGeom = new THREE.CylinderGeometry(0.05, 0.05, 0.55, 8);
            const leftArm = new THREE.Mesh(armGeom, personMaterial);
            leftArm.position.set(-0.28, 1.1, 0);
            personMesh.add(leftArm);
            const rightArm = new THREE.Mesh(armGeom, personMaterial);
            rightArm.position.set(0.28, 1.1, 0);
            personMesh.add(rightArm);

            // Neck
            const neckGeom = new THREE.CylinderGeometry(0.06, 0.08, 0.12, 8);
            const neck = new THREE.Mesh(neckGeom, personMaterial);
            neck.position.set(0, 1.46, 0);
            personMesh.add(neck);

            // Head (sphere)
            const headGeom = new THREE.SphereGeometry(0.13, 16, 12);
            const head = new THREE.Mesh(headGeom, personMaterial);
            head.position.set(0, 1.65, 0);
            personMesh.add(head);

            updatePersonTransform();
            scene.add(personMesh);
        }

        function updatePersonTransform() {
            if (!personMesh) return;
            personMesh.position.set(personSettings.posX, 0, personSettings.posZ);
            personMesh.rotation.y = personSettings.rotY * Math.PI / 180;
            personMesh.scale.setScalar(personSettings.scale);
            
            if (selectedObject === 'person') {
                updateGizmoPosition();
            }
        }

        function removePersonMesh() {
            if (personMesh) {
                scene.remove(personMesh);
                personMesh.traverse((child) => {
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) child.material.dispose();
                });
                personMesh = null;
            }
        }

        function createCarMesh() {
            if (carMesh) {
                scene.remove(carMesh);
                carMesh.traverse((child) => {
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) child.material.dispose();
                });
            }

            carMesh = new THREE.Group();
            const bodyMaterial = new THREE.MeshBasicMaterial({ color: 0xff4444, transparent: true, opacity: 0.85 });
            const darkMaterial = new THREE.MeshBasicMaterial({ color: 0x222222, transparent: true, opacity: 0.9 });
            const glassMaterial = new THREE.MeshBasicMaterial({ color: 0x88ccff, transparent: true, opacity: 0.5 });

            // Main body (lower)
            const bodyLowerGeom = new THREE.BoxGeometry(4.5, 0.8, 1.8);
            const bodyLower = new THREE.Mesh(bodyLowerGeom, bodyMaterial);
            bodyLower.position.set(0, 0.55, 0);
            carMesh.add(bodyLower);

            // Cabin (upper)
            const cabinGeom = new THREE.BoxGeometry(2.2, 0.7, 1.6);
            const cabin = new THREE.Mesh(cabinGeom, bodyMaterial);
            cabin.position.set(-0.3, 1.25, 0);
            carMesh.add(cabin);

            // Windshield (angled)
            const windshieldGeom = new THREE.BoxGeometry(0.05, 0.65, 1.5);
            const windshield = new THREE.Mesh(windshieldGeom, glassMaterial);
            windshield.position.set(0.75, 1.2, 0);
            windshield.rotation.z = -0.5;
            carMesh.add(windshield);

            // Rear window
            const rearWindowGeom = new THREE.BoxGeometry(0.05, 0.55, 1.5);
            const rearWindow = new THREE.Mesh(rearWindowGeom, glassMaterial);
            rearWindow.position.set(-1.35, 1.2, 0);
            rearWindow.rotation.z = 0.4;
            carMesh.add(rearWindow);

            // Wheels (4)
            const wheelGeom = new THREE.CylinderGeometry(0.35, 0.35, 0.2, 16);
            const wheelPositions = [
                { x: 1.4, z: 0.9 }, { x: 1.4, z: -0.9 },
                { x: -1.4, z: 0.9 }, { x: -1.4, z: -0.9 }
            ];
            wheelPositions.forEach(pos => {
                const wheel = new THREE.Mesh(wheelGeom, darkMaterial);
                wheel.position.set(pos.x, 0.35, pos.z);
                wheel.rotation.x = Math.PI / 2;
                carMesh.add(wheel);
            });

            // Headlights
            const lightGeom = new THREE.BoxGeometry(0.05, 0.15, 0.3);
            const lightMat = new THREE.MeshBasicMaterial({ color: 0xffffaa });
            [-0.6, 0.6].forEach(z => {
                const light = new THREE.Mesh(lightGeom, lightMat);
                light.position.set(2.25, 0.55, z);
                carMesh.add(light);
            });

            // Scale car down to reasonable size (car is ~4.5m long, scale to ~4.5m)
            carMesh.scale.setScalar(1);
            
            updateCarTransform();
            scene.add(carMesh);
        }

        function updateCarTransform() {
            if (!carMesh) return;
            carMesh.position.set(carSettings.posX, 0, carSettings.posZ);
            carMesh.rotation.y = carSettings.rotY * Math.PI / 180;
            carMesh.scale.setScalar(carSettings.scale);
            
            if (selectedObject === 'car') {
                updateGizmoPosition();
            }
        }

        function removeCarMesh() {
            if (carMesh) {
                scene.remove(carMesh);
                carMesh.traverse((child) => {
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) child.material.dispose();
                });
                carMesh = null;
            }
        }

        // Gizmo System
        function createGizmo() {
            if (gizmoGroup) {
                scene.remove(gizmoGroup);
                gizmoGroup = null;
            }
            
            if (!selectedObject || !gizmoMode) return;
            
            gizmoGroup = new THREE.Group();
            gizmoGroup.renderOrder = 999;
            gizmoHandles = {};
            
            const scale = 0.7; // Larger gizmos
            const defaultOpacity = 0.35; // Semi-transparent by default
            
            const createGizmoMaterial = (color) => {
                return new THREE.MeshBasicMaterial({ 
                    color: color, 
                    transparent: true, 
                    opacity: defaultOpacity,
                    depthTest: false,
                    depthWrite: false
                });
            };
            
            if (gizmoMode === 'translate') {
                const arrowLength = 1.2 * scale;
                const arrowHeadLength = 0.28 * scale;
                const arrowHeadRadius = 0.12 * scale;
                const shaftRadius = 0.04 * scale;
                
                // X axis (red)
                const xMat = createGizmoMaterial(0xff4444);
                const xShaft = new THREE.Mesh(new THREE.CylinderGeometry(shaftRadius, shaftRadius, arrowLength - arrowHeadLength, 12), xMat);
                xShaft.rotation.z = -Math.PI / 2;
                xShaft.position.x = (arrowLength - arrowHeadLength) / 2;
                const xHead = new THREE.Mesh(new THREE.ConeGeometry(arrowHeadRadius, arrowHeadLength, 16), xMat);
                xHead.rotation.z = -Math.PI / 2;
                xHead.position.x = arrowLength - arrowHeadLength / 2;
                const xArrow = new THREE.Group();
                xArrow.add(xShaft, xHead);
                xArrow.userData = { axis: 'x', type: 'translate', material: xMat, color: 0xff4444 };
                gizmoHandles.x = xArrow;
                gizmoGroup.add(xArrow);
                
                // Y axis (green)
                const yMat = createGizmoMaterial(0x44ff44);
                const yShaft = new THREE.Mesh(new THREE.CylinderGeometry(shaftRadius, shaftRadius, arrowLength - arrowHeadLength, 12), yMat);
                yShaft.position.y = (arrowLength - arrowHeadLength) / 2;
                const yHead = new THREE.Mesh(new THREE.ConeGeometry(arrowHeadRadius, arrowHeadLength, 16), yMat);
                yHead.position.y = arrowLength - arrowHeadLength / 2;
                const yArrow = new THREE.Group();
                yArrow.add(yShaft, yHead);
                yArrow.userData = { axis: 'y', type: 'translate', material: yMat, color: 0x44ff44 };
                gizmoHandles.y = yArrow;
                gizmoGroup.add(yArrow);
                
                // Z axis (blue)
                const zMat = createGizmoMaterial(0x4444ff);
                const zShaft = new THREE.Mesh(new THREE.CylinderGeometry(shaftRadius, shaftRadius, arrowLength - arrowHeadLength, 12), zMat);
                zShaft.rotation.x = Math.PI / 2;
                zShaft.position.z = (arrowLength - arrowHeadLength) / 2;
                const zHead = new THREE.Mesh(new THREE.ConeGeometry(arrowHeadRadius, arrowHeadLength, 16), zMat);
                zHead.rotation.x = Math.PI / 2;
                zHead.position.z = arrowLength - arrowHeadLength / 2;
                const zArrow = new THREE.Group();
                zArrow.add(zShaft, zHead);
                zArrow.userData = { axis: 'z', type: 'translate', material: zMat, color: 0x4444ff };
                gizmoHandles.z = zArrow;
                gizmoGroup.add(zArrow);
                
            } else if (gizmoMode === 'rotate') {
                const ringRadius = 0.65 * scale;
                const tubeRadius = 0.04 * scale;
                
                // X rotation ring (red)
                const xMat = createGizmoMaterial(0xff4444);
                const xRing = new THREE.Mesh(new THREE.TorusGeometry(ringRadius, tubeRadius, 12, 48), xMat);
                xRing.rotation.y = Math.PI / 2;
                xRing.userData = { axis: 'x', type: 'rotate', material: xMat, color: 0xff4444 };
                gizmoHandles.rx = xRing;
                gizmoGroup.add(xRing);
                
                // Y rotation ring (green)
                const yMat = createGizmoMaterial(0x44ff44);
                const yRing = new THREE.Mesh(new THREE.TorusGeometry(ringRadius, tubeRadius, 12, 48), yMat);
                yRing.rotation.x = Math.PI / 2;
                yRing.userData = { axis: 'y', type: 'rotate', material: yMat, color: 0x44ff44 };
                gizmoHandles.ry = yRing;
                gizmoGroup.add(yRing);
                
                // Z rotation ring (blue)
                const zMat = createGizmoMaterial(0x4444ff);
                const zRing = new THREE.Mesh(new THREE.TorusGeometry(ringRadius, tubeRadius, 12, 48), zMat);
                zRing.userData = { axis: 'z', type: 'rotate', material: zMat, color: 0x4444ff };
                gizmoHandles.rz = zRing;
                gizmoGroup.add(zRing);
            }
            
            updateGizmoOrientation();
            updateGizmoPosition();
            scene.add(gizmoGroup);
        }
        
        function updateGizmoOrientation() {
            if (!gizmoGroup || !selectedObject) return;
            
            gizmoGroup.rotation.set(0, 0, 0);
            
            if (gizmoSpace === 'local') {
                if (selectedObject === 'camera') {
                    gizmoGroup.rotation.order = 'YXZ';
                    gizmoGroup.rotation.set(
                        cameraSettings.rotX * Math.PI / 180,
                        cameraSettings.rotY * Math.PI / 180,
                        cameraSettings.rotZ * Math.PI / 180
                    );
                } else if (selectedObject === 'person') {
                    gizmoGroup.rotation.y = personSettings.rotY * Math.PI / 180;
                } else if (selectedObject === 'car') {
                    gizmoGroup.rotation.y = carSettings.rotY * Math.PI / 180;
                }
            }
        }
        
        function updateGizmoPosition() {
            if (!gizmoGroup || !selectedObject) return;
            
            let pos;
            if (selectedObject === 'camera' && previewCameraGroup) {
                pos = new THREE.Vector3(cameraSettings.posX, cameraSettings.posY, cameraSettings.posZ);
            } else if (selectedObject === 'person' && personMesh) {
                pos = new THREE.Vector3(personSettings.posX, 0.9, personSettings.posZ);
            } else if (selectedObject === 'car' && carMesh) {
                pos = new THREE.Vector3(carSettings.posX, 0.5, carSettings.posZ);
            } else {
                return;
            }
            
            gizmoGroup.position.copy(pos);
        }
        
        function selectObject(objName) {
            selectedObject = objName;
            updateSelectionIndicator();
            createGizmo();
        }
        
        function deselectObject() {
            selectedObject = null;
            hoveredGizmoAxis = null;
            updateSelectionIndicator();
            if (gizmoGroup) {
                scene.remove(gizmoGroup);
                gizmoGroup = null;
            }
        }
        
        function updateSelectionIndicator() {
            const indicator = document.getElementById('selection-indicator');
            const nameSpan = indicator.querySelector('.selected-name');
            
            if (selectedObject) {
                indicator.classList.add('visible');
                const names = { camera: 'Camera', person: 'Person', car: 'Car' };
                nameSpan.textContent = names[selectedObject] || 'Unknown';
            } else {
                indicator.classList.remove('visible');
                nameSpan.textContent = 'None';
            }
        }
        
        function setGizmoMode(mode) {
            if (gizmoMode === mode) {
                gizmoMode = null;
            } else {
                gizmoMode = mode;
            }
            
            document.getElementById('gizmo-translate').classList.toggle('active', gizmoMode === 'translate');
            document.getElementById('gizmo-rotate').classList.toggle('active', gizmoMode === 'rotate');
            
            createGizmo();
        }
        
        function toggleGizmoSpace() {
            gizmoSpace = gizmoSpace === 'world' ? 'local' : 'world';
            const btn = document.getElementById('gizmo-space');
            btn.textContent = gizmoSpace === 'world' ? 'W' : 'L';
            btn.classList.toggle('world', gizmoSpace === 'world');
            btn.classList.toggle('local', gizmoSpace === 'local');
            btn.title = gizmoSpace === 'world' ? 'World Space (L to toggle)' : 'Local Space (L to toggle)';
            
            if (gizmoGroup) {
                updateGizmoOrientation();
            }
        }
        
        function updateGizmoHover(event) {
            if (!gizmoGroup || isDraggingGizmo || pilotMode) return;
            
            const canvas = renderer.domElement;
            const rect = canvas.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            
            const gizmoMeshes = [];
            Object.values(gizmoHandles).forEach(handle => {
                handle.traverse(child => {
                    if (child.isMesh) {
                        child.userData = { ...handle.userData };
                        gizmoMeshes.push(child);
                    }
                });
            });
            
            const intersects = raycaster.intersectObjects(gizmoMeshes, false);
            const newHovered = intersects.length > 0 ? intersects[0].object.userData.axis : null;
            
            if (newHovered !== hoveredGizmoAxis) {
                hoveredGizmoAxis = newHovered;
                
                Object.values(gizmoHandles).forEach(handle => {
                    const isHovered = handle.userData.axis === hoveredGizmoAxis;
                    handle.traverse(child => {
                        if (child.material) {
                            child.material.opacity = isHovered ? 1.0 : 0.35;
                        }
                    });
                });
            }
        }
        
        function handleGizmoMouseDown(event) {
            if (!gizmoGroup || !selectedObject || pilotMode) return false;
            
            const canvas = renderer.domElement;
            const rect = canvas.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            
            const gizmoMeshes = [];
            Object.values(gizmoHandles).forEach(handle => {
                handle.traverse(child => {
                    if (child.isMesh) {
                        child.userData = { ...handle.userData };
                        gizmoMeshes.push(child);
                    }
                });
            });
            
            const intersects = raycaster.intersectObjects(gizmoMeshes, false);
            
            if (intersects.length > 0) {
                const hit = intersects[0];
                activeGizmoAxis = hit.object.userData.axis;
                isDraggingGizmo = true;
                
                // Highlight active axis
                Object.values(gizmoHandles).forEach(handle => {
                    const isActive = handle.userData.axis === activeGizmoAxis;
                    handle.traverse(child => {
                        if (child.material) {
                            child.material.opacity = isActive ? 1.0 : 0.15;
                        }
                    });
                });
                
                const gizmoPos = gizmoGroup.position.clone();
                
                if (gizmoMode === 'translate') {
                    let axisDir = new THREE.Vector3();
                    if (activeGizmoAxis === 'x') axisDir.set(1, 0, 0);
                    else if (activeGizmoAxis === 'y') axisDir.set(0, 1, 0);
                    else axisDir.set(0, 0, 1);
                    
                    if (gizmoSpace === 'local') {
                        axisDir.applyQuaternion(gizmoGroup.quaternion);
                    }
                    
                    const cameraDir = camera.position.clone().sub(gizmoPos).normalize();
                    const planeNormal = cameraDir.clone().cross(axisDir).cross(axisDir).normalize();
                    
                    if (planeNormal.length() < 0.1) {
                        planeNormal.copy(cameraDir);
                    }
                    
                    dragPlane.setFromNormalAndCoplanarPoint(planeNormal, gizmoPos);
                } else if (gizmoMode === 'rotate') {
                    let planeNormal = new THREE.Vector3();
                    if (activeGizmoAxis === 'x') planeNormal.set(1, 0, 0);
                    else if (activeGizmoAxis === 'y') planeNormal.set(0, 1, 0);
                    else planeNormal.set(0, 0, 1);
                    
                    if (gizmoSpace === 'local') {
                        planeNormal.applyQuaternion(gizmoGroup.quaternion);
                    }
                    
                    dragPlane.setFromNormalAndCoplanarPoint(planeNormal, gizmoPos);
                }
                
                raycaster.ray.intersectPlane(dragPlane, dragStartPoint);
                return true;
            }
            
            return false;
        }
        
        function handleGizmoMouseMove(event) {
            if (!isDraggingGizmo || !activeGizmoAxis || !gizmoGroup) return;
            
            const canvas = renderer.domElement;
            const rect = canvas.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            
            const currentPoint = new THREE.Vector3();
            if (!raycaster.ray.intersectPlane(dragPlane, currentPoint)) return;
            
            if (gizmoMode === 'translate') {
                const delta = currentPoint.clone().sub(dragStartPoint);
                
                let axisDir = new THREE.Vector3();
                if (activeGizmoAxis === 'x') axisDir.set(1, 0, 0);
                else if (activeGizmoAxis === 'y') axisDir.set(0, 1, 0);
                else axisDir.set(0, 0, 1);
                
                if (gizmoSpace === 'local') {
                    axisDir.applyQuaternion(gizmoGroup.quaternion);
                }
                
                const axisDelta = delta.dot(axisDir);
                const movement = axisDir.clone().multiplyScalar(axisDelta);
                
                if (selectedObject === 'camera') {
                    cameraSettings.posX += movement.x;
                    cameraSettings.posY = Math.max(0, cameraSettings.posY + movement.y);
                    cameraSettings.posZ += movement.z;
                    
                    document.getElementById('camera-pos-x').value = cameraSettings.posX.toFixed(2);
                    document.getElementById('camera-pos-y').value = cameraSettings.posY.toFixed(2);
                    document.getElementById('camera-pos-z').value = cameraSettings.posZ.toFixed(2);
                    
                    if (cameraPreviewEnabled) updateCameraFrustum();
                } else if (selectedObject === 'person') {
                    personSettings.posX += movement.x;
                    personSettings.posZ += movement.z;
                    
                    document.getElementById('person-pos-x').value = personSettings.posX.toFixed(2);
                    document.getElementById('person-pos-z').value = personSettings.posZ.toFixed(2);
                    updatePersonTransform();
                } else if (selectedObject === 'car') {
                    carSettings.posX += movement.x;
                    carSettings.posZ += movement.z;
                    
                    document.getElementById('car-pos-x').value = carSettings.posX.toFixed(2);
                    document.getElementById('car-pos-z').value = carSettings.posZ.toFixed(2);
                    updateCarTransform();
                }
                
            } else if (gizmoMode === 'rotate') {
                const gizmoPos = gizmoGroup.position.clone();
                const startDir = dragStartPoint.clone().sub(gizmoPos).normalize();
                const currentDir = currentPoint.clone().sub(gizmoPos).normalize();
                
                let angle = Math.atan2(
                    startDir.clone().cross(currentDir).dot(dragPlane.normal),
                    startDir.dot(currentDir)
                );
                
                angle = angle * (180 / Math.PI);
                
                if (selectedObject === 'camera') {
                    if (activeGizmoAxis === 'x') {
                        cameraSettings.rotX = Math.max(-90, Math.min(90, cameraSettings.rotX - angle));
                        document.getElementById('camera-rot-x').value = cameraSettings.rotX.toFixed(1);
                    } else if (activeGizmoAxis === 'y') {
                        cameraSettings.rotY -= angle;
                        document.getElementById('camera-rot-y').value = cameraSettings.rotY.toFixed(1);
                    } else {
                        cameraSettings.rotZ = Math.max(-180, Math.min(180, cameraSettings.rotZ - angle));
                        document.getElementById('camera-rot-z').value = cameraSettings.rotZ.toFixed(1);
                    }
                    
                    if (cameraPreviewEnabled) updateCameraFrustum();
                } else if (selectedObject === 'person') {
                    if (activeGizmoAxis === 'y') {
                        personSettings.rotY -= angle;
                        document.getElementById('person-rot-y').value = personSettings.rotY.toFixed(1);
                        updatePersonTransform();
                    }
                } else if (selectedObject === 'car') {
                    if (activeGizmoAxis === 'y') {
                        carSettings.rotY -= angle;
                        document.getElementById('car-rot-y').value = carSettings.rotY.toFixed(1);
                        updateCarTransform();
                    }
                }
                
                if (gizmoSpace === 'local') {
                    updateGizmoOrientation();
                }
            }
            
            dragStartPoint.copy(currentPoint);
            updateGizmoPosition();
        }
        
        function handleGizmoMouseUp() {
            isDraggingGizmo = false;
            activeGizmoAxis = null;
            
            if (gizmoGroup) {
                Object.values(gizmoHandles).forEach(handle => {
                    const isHovered = handle.userData.axis === hoveredGizmoAxis;
                    handle.traverse(child => {
                        if (child.material) {
                            child.material.opacity = isHovered ? 1.0 : 0.35;
                        }
                    });
                });
            }
        }
        
        function handleViewportClick(event) {
            if (isDraggingGizmo || pilotMode) return;
            if (!gizmoMode) return;
            
            const canvas = renderer.domElement;
            const rect = canvas.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            
            const selectables = [];
            
            // Only select camera BODY, not frustum
            if (cameraPreviewEnabled && cameraBodyMesh) {
                cameraBodyMesh.userData.selectType = 'camera';
                selectables.push(cameraBodyMesh);
            }
            
            if (showPerson && personMesh) {
                personMesh.traverse(child => {
                    if (child.isMesh) {
                        child.userData.selectType = 'person';
                        selectables.push(child);
                    }
                });
            }
            
            if (showCar && carMesh) {
                carMesh.traverse(child => {
                    if (child.isMesh) {
                        child.userData.selectType = 'car';
                        selectables.push(child);
                    }
                });
            }
            
            const intersects = raycaster.intersectObjects(selectables, false);
            
            if (intersects.length > 0) {
                const selectType = intersects[0].object.userData.selectType;
                if (selectType && selectType !== selectedObject) {
                    selectObject(selectType);
                }
            } else {
                deselectObject();
            }
        }
        
        // Pilot Camera Mode
        function togglePilotMode() {
            if (!cameraPreviewEnabled) {
                alert('Enable Camera Frustum Preview first to use Pilot Mode');
                return;
            }
            
            pilotMode = !pilotMode;
            document.getElementById('gizmo-pilot').classList.toggle('active', pilotMode);
            document.getElementById('pilot-info').classList.toggle('visible', pilotMode);
            
            if (pilotMode) {
                savedCameraState = {
                    position: camera.position.clone(),
                    cameraAngle: { ...cameraAngle },
                    cameraDistance: cameraDistance,
                    targetOffset: targetOffset.clone(),
                    fov: camera.fov
                };
                
                enterPilotView();
            } else {
                if (savedCameraState) {
                    camera.position.copy(savedCameraState.position);
                    cameraAngle = { ...savedCameraState.cameraAngle };
                    cameraDistance = savedCameraState.cameraDistance;
                    targetOffset.copy(savedCameraState.targetOffset);
                    camera.fov = savedCameraState.fov;
                    camera.updateProjectionMatrix();
                    updateCameraPosition();
                }
                isPilotLooking = false;
            }
        }
        
        function enterPilotView() {
            if (!cameraPreviewEnabled || !previewCameraGroup) return;
            
            camera.position.set(cameraSettings.posX, cameraSettings.posY, cameraSettings.posZ);
            
            const tilt = cameraSettings.rotX * Math.PI / 180;
            const pan = cameraSettings.rotY * Math.PI / 180;
            
            const lookDir = new THREE.Vector3(0, 0, -1);
            lookDir.applyAxisAngle(new THREE.Vector3(1, 0, 0), tilt);
            lookDir.applyAxisAngle(new THREE.Vector3(0, 1, 0), pan);
            
            const lookTarget = camera.position.clone().add(lookDir);
            camera.lookAt(lookTarget);
            camera.rotateZ(cameraSettings.rotZ * Math.PI / 180);
            
            const vFov = 2 * Math.atan(cameraSettings.filmbackHeight / (2 * cameraSettings.focalLength)) * (180 / Math.PI);
            camera.fov = vFov;
            camera.updateProjectionMatrix();
        }
        
        function updatePilotView() {
            if (pilotMode) {
                enterPilotView();
            }
        }
        
        function handlePilotMouseDown(event) {
            if (!pilotMode) return;
            isPilotLooking = true;
            pilotLastMouse = { x: event.clientX, y: event.clientY };
        }
        
        function handlePilotMouseMove(event) {
            if (!pilotMode || !isPilotLooking) return;
            
            const deltaX = event.clientX - pilotLastMouse.x;
            const deltaY = event.clientY - pilotLastMouse.y;
            pilotLastMouse = { x: event.clientX, y: event.clientY };
            
            cameraSettings.rotY -= deltaX * 0.3;
            cameraSettings.rotX = Math.max(-90, Math.min(90, cameraSettings.rotX - deltaY * 0.3));
            
            document.getElementById('camera-rot-x').value = cameraSettings.rotX.toFixed(1);
            document.getElementById('camera-rot-y').value = cameraSettings.rotY.toFixed(1);
            
            if (cameraPreviewEnabled) updateCameraFrustum();
        }
        
        function handlePilotMouseUp() {
            isPilotLooking = false;
        }
        
        function handlePilotKeyboard() {
            if (!pilotMode) return;
            
            const pan = cameraSettings.rotY * Math.PI / 180;
            const tilt = cameraSettings.rotX * Math.PI / 180;
            
            const forward = new THREE.Vector3(
                -Math.sin(pan) * Math.cos(tilt),
                -Math.sin(tilt),
                -Math.cos(pan) * Math.cos(tilt)
            ).normalize();
            
            const right = new THREE.Vector3(Math.cos(pan), 0, -Math.sin(pan)).normalize();
            
            let moved = false;
            
            if (keysPressed['KeyW'] || keysPressed['ArrowUp']) {
                cameraSettings.posX += forward.x * pilotMoveSpeed;
                cameraSettings.posY += forward.y * pilotMoveSpeed;
                cameraSettings.posZ += forward.z * pilotMoveSpeed;
                moved = true;
            }
            if (keysPressed['KeyS'] || keysPressed['ArrowDown']) {
                cameraSettings.posX -= forward.x * pilotMoveSpeed;
                cameraSettings.posY -= forward.y * pilotMoveSpeed;
                cameraSettings.posZ -= forward.z * pilotMoveSpeed;
                moved = true;
            }
            if (keysPressed['KeyA'] || keysPressed['ArrowLeft']) {
                cameraSettings.posX -= right.x * pilotMoveSpeed;
                cameraSettings.posZ -= right.z * pilotMoveSpeed;
                moved = true;
            }
            if (keysPressed['KeyD'] || keysPressed['ArrowRight']) {
                cameraSettings.posX += right.x * pilotMoveSpeed;
                cameraSettings.posZ += right.z * pilotMoveSpeed;
                moved = true;
            }
            if (keysPressed['KeyQ']) {
                cameraSettings.posY -= pilotMoveSpeed;
                moved = true;
            }
            if (keysPressed['KeyE']) {
                cameraSettings.posY += pilotMoveSpeed;
                moved = true;
            }
            
            cameraSettings.posY = Math.max(0.1, cameraSettings.posY);
            
            if (moved) {
                document.getElementById('camera-pos-x').value = cameraSettings.posX.toFixed(2);
                document.getElementById('camera-pos-y').value = cameraSettings.posY.toFixed(2);
                document.getElementById('camera-pos-z').value = cameraSettings.posZ.toFixed(2);
                
                if (cameraPreviewEnabled) updateCameraFrustum();
            }
        }
        
        function handlePilotWheel(event) {
            if (!pilotMode) return;
            event.preventDefault();
            
            if (event.deltaY > 0) {
                pilotMoveSpeed = Math.max(0.01, pilotMoveSpeed * 0.85);
            } else {
                pilotMoveSpeed = Math.min(0.3, pilotMoveSpeed * 1.15);
            }
        }

        // Preview Camera Functions
        function initPreviewCamera() {
            const previewCanvas = document.getElementById('camera-preview-canvas');
            previewRenderer = new THREE.WebGLRenderer({ canvas: previewCanvas, antialias: true });
            previewRenderer.setSize(320, 180);
            previewRenderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

            // Create preview camera with settings matching the frustum
            updatePreviewCamera();
            
            // Setup resize functionality
            setupPreviewResize();
        }

        function setupPreviewResize() {
            const previewWindow = document.getElementById('camera-preview-window');
            const resizeHandle = document.getElementById('camera-preview-resize');
            let isResizing = false;
            let startX, startY, startWidth, startHeight;

            resizeHandle.addEventListener('mousedown', (e) => {
                e.preventDefault();
                e.stopPropagation();
                isResizing = true;
                startX = e.clientX;
                startY = e.clientY;
                startWidth = previewWindow.offsetWidth;
                startHeight = previewWindow.offsetHeight;
                document.body.style.cursor = 'nw-resize';
            });

            document.addEventListener('mousemove', (e) => {
                if (!isResizing) return;
                
                // Calculate new dimensions (resizing from top-left, window anchored to bottom-right)
                const deltaX = startX - e.clientX;
                const deltaY = startY - e.clientY;
                
                // Maintain aspect ratio based on filmback
                const aspect = cameraSettings.filmbackWidth / cameraSettings.filmbackHeight;
                let newWidth = Math.max(200, Math.min(800, startWidth + deltaX));
                let newHeight = newWidth / aspect;
                
                // Clamp height and recalculate width if needed
                if (newHeight < 120) {
                    newHeight = 120;
                    newWidth = newHeight * aspect;
                } else if (newHeight > 600) {
                    newHeight = 600;
                    newWidth = newHeight * aspect;
                }
                
                previewWindow.style.width = `${newWidth}px`;
                previewWindow.style.height = `${newHeight}px`;
                
                // Update renderer size
                if (previewRenderer) {
                    previewRenderer.setSize(newWidth, newHeight);
                }
            });

            document.addEventListener('mouseup', () => {
                if (isResizing) {
                    isResizing = false;
                    document.body.style.cursor = '';
                }
            });
        }

        function updatePreviewCamera() {
            const hFov = 2 * Math.atan(cameraSettings.filmbackWidth / (2 * cameraSettings.focalLength)) * 180 / Math.PI;
            const vFov = 2 * Math.atan(cameraSettings.filmbackHeight / (2 * cameraSettings.focalLength)) * 180 / Math.PI;
            const aspect = cameraSettings.filmbackWidth / cameraSettings.filmbackHeight;

            if (!previewCamera) {
                previewCamera = new THREE.PerspectiveCamera(vFov, aspect, 0.1, 100);
            } else {
                previewCamera.fov = vFov;
                previewCamera.aspect = aspect;
                previewCamera.updateProjectionMatrix();
            }

            // Position and rotate to match frustum camera
            previewCamera.position.set(
                cameraSettings.posX,
                cameraSettings.posY,
                cameraSettings.posZ
            );

            // Apply rotations using YXZ order to avoid gimbal lock
            const tilt = cameraSettings.rotX * Math.PI / 180;
            const pan = cameraSettings.rotY * Math.PI / 180;
            const roll = cameraSettings.rotZ * Math.PI / 180;
            
            previewCamera.rotation.order = 'YXZ';
            previewCamera.rotation.set(tilt, pan, roll);

            // Update preview info
            document.getElementById('camera-preview-info').textContent = 
                `${cameraSettings.focalLength}mm â€¢ ${filmbackPresets[cameraSettings.filmback]?.name.split(' ')[0] || 'Custom'}`;
            document.getElementById('camera-preview-fov').textContent = 
                `H: ${hFov.toFixed(1)}Â° V: ${vFov.toFixed(1)}Â°`;
            
            // Calculate approx resolution based on aspect
            const baseHeight = 1080;
            const width = Math.round(baseHeight * aspect);
            document.getElementById('camera-preview-res').textContent = `${width}Ã—${baseHeight}`;
        }

        function renderPreviewCamera() {
            if (!cameraPreviewEnabled || !previewRenderer || !previewCamera) return;
            previewRenderer.render(scene, previewCamera);
        }

        let isDragging = false, previousMousePosition = { x: 0, y: 0 };
        let cameraAngle = { theta: 0, phi: Math.PI / 2 }, cameraDistance = 8;
        let targetPosition = new THREE.Vector3(0, 0, 0);
        let targetOffset = new THREE.Vector3(0, 0, 0); // Manual offset from calculated center
        
        // Keyboard state for WASD+QE navigation
        const keysPressed = {};
        const moveSpeed = 0.08;

        function updateTargetPosition() {
            const scale = 0.001;
            let totalWidth = 0, maxHeight = 0;
            wallSections.forEach(s => {
                totalWidth += s.panelCols * s.panelWidth * scale;
                maxHeight = Math.max(maxHeight, s.panelRows * s.panelHeight * scale);
            });
            targetPosition.set(totalWidth / 2 + targetOffset.x, maxHeight / 2 + targetOffset.y, targetOffset.z);
        }

        function handleKeyboardMovement() {
            // Skip movement controls in pilot mode
            if (pilotMode) return;
            
            // Calculate forward/right vectors based on camera angle
            const forward = new THREE.Vector3(
                Math.sin(cameraAngle.theta),
                0,
                Math.cos(cameraAngle.theta)
            );
            const right = new THREE.Vector3(
                Math.cos(cameraAngle.theta),
                0,
                -Math.sin(cameraAngle.theta)
            );

            let moved = false;

            // W/S - Forward/Backward
            if (keysPressed['KeyW'] || keysPressed['ArrowUp']) {
                targetOffset.add(forward.clone().multiplyScalar(-moveSpeed));
                moved = true;
            }
            if (keysPressed['KeyS'] || keysPressed['ArrowDown']) {
                targetOffset.add(forward.clone().multiplyScalar(moveSpeed));
                moved = true;
            }

            // A/D - Left/Right
            if (keysPressed['KeyA'] || keysPressed['ArrowLeft']) {
                targetOffset.add(right.clone().multiplyScalar(-moveSpeed));
                moved = true;
            }
            if (keysPressed['KeyD'] || keysPressed['ArrowRight']) {
                targetOffset.add(right.clone().multiplyScalar(moveSpeed));
                moved = true;
            }

            // Q/E - Down/Up
            if (keysPressed['KeyQ']) {
                targetOffset.y -= moveSpeed;
                moved = true;
            }
            if (keysPressed['KeyE']) {
                targetOffset.y += moveSpeed;
                moved = true;
            }

            if (moved) {
                updateCameraPosition();
            }
        }

        function setupControls() {
            const canvas = renderer.domElement;
            canvas.addEventListener('mousedown', (e) => { 
                if (isDraggingGizmo || pilotMode) return;
                isDragging = true; 
                previousMousePosition = { x: e.clientX, y: e.clientY }; 
            });
            canvas.addEventListener('mousemove', (e) => {
                if (!isDragging || isDraggingGizmo || pilotMode) return;
                cameraAngle.theta -= (e.clientX - previousMousePosition.x) * 0.01;
                cameraAngle.phi = Math.max(0.1, Math.min(Math.PI - 0.1, cameraAngle.phi - (e.clientY - previousMousePosition.y) * 0.01));
                previousMousePosition = { x: e.clientX, y: e.clientY };
                updateCameraPosition();
            });
            canvas.addEventListener('mouseup', () => isDragging = false);
            canvas.addEventListener('mouseleave', () => isDragging = false);
            canvas.addEventListener('wheel', (e) => { 
                if (pilotMode) return;
                e.preventDefault(); 
                cameraDistance = Math.max(2, Math.min(30, cameraDistance + e.deltaY * 0.01)); 
                updateCameraPosition(); 
            });
            
            // Keyboard controls for WASD+QE navigation
            document.addEventListener('keydown', (e) => {
                // Don't capture if typing in an input field
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT' || e.target.tagName === 'TEXTAREA') return;
                keysPressed[e.code] = true;
            });
            document.addEventListener('keyup', (e) => {
                keysPressed[e.code] = false;
            });
            // Clear keys when window loses focus
            window.addEventListener('blur', () => {
                Object.keys(keysPressed).forEach(key => keysPressed[key] = false);
            });
        }

        function updateCameraPosition() {
            updateTargetPosition();
            camera.position.x = targetPosition.x + cameraDistance * Math.sin(cameraAngle.phi) * Math.sin(cameraAngle.theta);
            camera.position.y = targetPosition.y + cameraDistance * Math.cos(cameraAngle.phi);
            camera.position.z = targetPosition.z + cameraDistance * Math.sin(cameraAngle.phi) * Math.cos(cameraAngle.theta);
            camera.lookAt(targetPosition);
        }

        function setView(view) {
            if (view === 'front') cameraAngle = { theta: 0, phi: Math.PI / 2 };
            else if (view === 'side') cameraAngle = { theta: Math.PI / 2, phi: Math.PI / 2 };
            else if (view === 'top') cameraAngle = { theta: 0, phi: 0.1 };
            else { 
                cameraAngle = { theta: 0.3, phi: Math.PI / 2.5 }; 
                cameraDistance = 8; 
                targetOffset.set(0, 0, 0); // Reset offset on view reset
            }
            updateCameraPosition();
        }

        function onResize() {
            const container = renderer.domElement.parentElement;
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            handleKeyboardMovement();
            handlePilotKeyboard();
            renderer.render(scene, camera);
            renderPreviewCamera();
        }

        function renderWallSections() {
            const container = document.getElementById('wall-sections');
            container.innerHTML = '';

            wallSections.forEach((section, index) => {
                const colorIndex = index % 8;
                const curveType = section.curveIntensity === 0 ? 'Flat' : (section.curveIntensity > 0 ? 'Concave' : 'Convex');
                
                // Ensure section has a name
                if (!section.name) section.name = `Wall ${index + 1}`;
                
                // Calculate canvas size and check if it exceeds 4K
                const canvasWidth = section.panelCols * section.ledX;
                const canvasHeight = section.panelRows * section.ledY;
                const summary = `${section.panelCols}Ã—${section.panelRows} â€¢ ${canvasWidth}Ã—${canvasHeight}px â€¢ ${curveType}`;
                
                const exceeds4K = (canvasWidth > 3840 || canvasHeight > 2160) && (canvasWidth > 2160 || canvasHeight > 3840);
                const warningHTML = exceeds4K ? `
                    <div class="section-warning">
                        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"/>
                            <line x1="12" y1="9" x2="12" y2="13"/><line x1="12" y1="17" x2="12.01" y2="17"/>
                        </svg>
                        <span>Canvas ${canvasWidth}Ã—${canvasHeight} exceeds 4K</span>
                    </div>` : '';

                const sectionEl = document.createElement('div');
                sectionEl.className = 'wall-section collapsed';
                sectionEl.innerHTML = `
                    <div class="section-header">
                        <div class="section-header-left">
                            <div class="section-color" style="background: ${section.color}"></div>
                            <div>
                                <div class="section-title">${section.name}${exceeds4K ? ' <span class="warning-indicator">âš </span>' : ''}</div>
                                <div class="section-summary">${summary}</div>
                            </div>
                        </div>
                        <div class="section-header-right">
                            ${wallSections.length > 1 ? `<button class="section-delete" data-id="${section.id}"><svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg></button>` : ''}
                            <div class="section-toggle"><svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="6 9 12 15 18 9"/></svg></div>
                        </div>
                    </div>
                    <div class="section-content">
                        ${warningHTML}
                        <div class="section-row single">
                            <div class="input-field">
                                <label>Section Name</label>
                                <input type="text" class="section-name-input" value="${section.name}" maxlength="32">
                            </div>
                        </div>
                        <div class="section-row">
                            <div class="input-field"><label>Columns</label><input type="number" data-field="panelCols" value="${section.panelCols}" min="1" max="100"></div>
                            <div class="input-field"><label>Rows</label><input type="number" data-field="panelRows" value="${section.panelRows}" min="1" max="100"></div>
                        </div>
                        <div class="section-row">
                            <div class="input-field"><label>Width (mm)</label><input type="number" data-field="panelWidth" value="${section.panelWidth}" min="50" max="5000"></div>
                            <div class="input-field"><label>Height (mm)</label><input type="number" data-field="panelHeight" value="${section.panelHeight}" min="50" max="5000"></div>
                        </div>
                        <div class="section-row">
                            <div class="input-field"><label>Pixels X</label><input type="number" data-field="ledX" value="${section.ledX}" min="8" max="1000"></div>
                            <div class="input-field"><label>Pixels Y</label><input type="number" data-field="ledY" value="${section.ledY}" min="8" max="1000"></div>
                        </div>
                        <div class="section-row">
                            <div class="input-field">
                                <label>Angle Between Panels (Â°)</label>
                                <input type="number" data-field="curveIntensity" value="${section.curveIntensity}" min="-45" max="45" step="0.1">
                                <div class="curve-hint">${curveType}${section.curveIntensity !== 0 ? ` (${section.curveIntensity > 0 ? '+' : ''}${section.curveIntensity}Â°)` : ''}</div>
                            </div>
                            <div class="input-field">
                                <label>Section Offset (Â°)</label>
                                <input type="number" data-field="angleOffset" value="${section.angleOffset || 0}" min="-180" max="180" step="1">
                                <div class="curve-hint" style="font-size: 9px;">Rotation before section</div>
                            </div>
                        </div>
                        <div class="section-row single">
                            <div class="input-field">
                                <label>Panel Color</label>
                                <div class="section-color-picker">
                                    <div class="color-swatch-small ${section.color === '#00f0ff' ? 'active' : ''}" data-color="#00f0ff" style="background: #00f0ff;"></div>
                                    <div class="color-swatch-small ${section.color === '#ff00aa' ? 'active' : ''}" data-color="#ff00aa" style="background: #ff00aa;"></div>
                                    <div class="color-swatch-small ${section.color === '#00ff66' ? 'active' : ''}" data-color="#00ff66" style="background: #00ff66;"></div>
                                    <div class="color-swatch-small ${section.color === '#ff6b35' ? 'active' : ''}" data-color="#ff6b35" style="background: #ff6b35;"></div>
                                    <div class="color-swatch-small ${section.color === '#ffffff' ? 'active' : ''}" data-color="#ffffff" style="background: #ffffff;"></div>
                                    <div class="color-swatch-small ${section.color === '#ffdd00' ? 'active' : ''}" data-color="#ffdd00" style="background: #ffdd00;"></div>
                                    <input type="color" class="color-input-custom" value="${section.color}" title="Custom color">
                                </div>
                            </div>
                        </div>
                    </div>`;

                container.appendChild(sectionEl);

                sectionEl.querySelector('.section-header').addEventListener('click', (e) => {
                    if (!e.target.closest('.section-delete')) sectionEl.classList.toggle('collapsed');
                });

                const deleteBtn = sectionEl.querySelector('.section-delete');
                if (deleteBtn) deleteBtn.addEventListener('click', (e) => { e.stopPropagation(); deleteSection(section.id); });

                // Color swatches
                sectionEl.querySelectorAll('.color-swatch-small').forEach(swatch => {
                    swatch.addEventListener('click', (e) => {
                        e.stopPropagation();
                        sectionEl.querySelectorAll('.color-swatch-small').forEach(s => s.classList.remove('active'));
                        swatch.classList.add('active');
                        section.color = swatch.dataset.color;
                        sectionEl.querySelector('.section-color').style.background = section.color;
                        sectionEl.querySelector('.color-input-custom').value = section.color;
                        createLEDWall();
                    });
                });

                // Custom color input
                sectionEl.querySelector('.color-input-custom').addEventListener('input', (e) => {
                    e.stopPropagation();
                    section.color = e.target.value;
                    sectionEl.querySelectorAll('.color-swatch-small').forEach(s => s.classList.remove('active'));
                    sectionEl.querySelector('.section-color').style.background = section.color;
                    createLEDWall();
                });

                // Section name input
                sectionEl.querySelector('.section-name-input').addEventListener('input', (e) => {
                    e.stopPropagation();
                    section.name = e.target.value || `Wall ${index + 1}`;
                    sectionEl.querySelector('.section-title').innerHTML = section.name + 
                        (sectionEl.querySelector('.warning-indicator') ? ' <span class="warning-indicator">âš </span>' : '');
                    if (panelIdsEnabled) createLEDWall();
                });
                sectionEl.querySelector('.section-name-input').addEventListener('click', (e) => e.stopPropagation());

                sectionEl.querySelectorAll('input[type="number"]').forEach(input => {
                    input.addEventListener('change', (e) => {
                        const field = e.target.dataset.field;
                        let value = parseFloat(e.target.value);
                        if (field === 'panelCols') value = Math.max(1, Math.min(50, value || 1));
                        else if (field === 'panelRows') value = Math.max(1, Math.min(20, value || 1));
                        else if (field === 'panelWidth' || field === 'panelHeight') value = Math.max(50, Math.min(5000, value || 500));
                        else if (field === 'ledX' || field === 'ledY') value = Math.max(8, Math.min(350, value || 32));
                        else if (field === 'curveIntensity') value = Math.max(-45, Math.min(45, value || 0));
                        else if (field === 'angleOffset') value = Math.max(-180, Math.min(180, value || 0));
                        e.target.value = value;
                        section[field] = value;
                        
                        // Update curve hint
                        if (field === 'curveIntensity') {
                            const hint = sectionEl.querySelector('.curve-hint');
                            const ct = value === 0 ? 'Flat' : (value > 0 ? 'Concave' : 'Convex');
                            hint.textContent = `${ct}${value !== 0 ? ` (${value > 0 ? '+' : ''}${value}Â°)` : ''}`;
                        }
                        
                        // Update summary with pixel dimensions
                        const canvasWidth = section.panelCols * section.ledX;
                        const canvasHeight = section.panelRows * section.ledY;
                        const curveType = section.curveIntensity === 0 ? 'Flat' : (section.curveIntensity > 0 ? 'Concave' : 'Convex');
                        sectionEl.querySelector('.section-summary').textContent = `${section.panelCols}Ã—${section.panelRows} â€¢ ${canvasWidth}Ã—${canvasHeight}px â€¢ ${curveType}`;
                        
                        // Update 4K warning
                        const exceeds4K = (canvasWidth > 3840 || canvasHeight > 2160) && (canvasWidth > 2160 || canvasHeight > 3840);
                        const existingWarning = sectionEl.querySelector('.section-warning');
                        const titleEl = sectionEl.querySelector('.section-title');
                        
                        if (exceeds4K && !existingWarning) {
                            const warningEl = document.createElement('div');
                            warningEl.className = 'section-warning';
                            warningEl.innerHTML = `<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"/><line x1="12" y1="9" x2="12" y2="13"/><line x1="12" y1="17" x2="12.01" y2="17"/></svg><span>Canvas ${canvasWidth}Ã—${canvasHeight} exceeds 4K</span>`;
                            sectionEl.querySelector('.section-content').insertBefore(warningEl, sectionEl.querySelector('.section-content').firstChild);
                            if (!titleEl.innerHTML.includes('warning-indicator')) {
                                titleEl.innerHTML = titleEl.innerHTML.replace(/Wall \d+/, `$& <span class="warning-indicator">âš </span>`);
                            }
                        } else if (!exceeds4K && existingWarning) {
                            existingWarning.remove();
                            titleEl.innerHTML = titleEl.innerHTML.replace(/ <span class="warning-indicator">âš <\/span>/, '');
                        } else if (exceeds4K && existingWarning) {
                            existingWarning.querySelector('span').textContent = `Canvas ${canvasWidth}Ã—${canvasHeight} exceeds 4K`;
                        }
                        
                        updateStats();
                        createLEDWall();
                    });
                    input.addEventListener('click', (e) => e.stopPropagation());
                });
            });
        }

        function addSection() {
            // Save collapsed states BEFORE adding new section
            const collapsedStates = {};
            document.querySelectorAll('.wall-section').forEach((el, idx) => {
                collapsedStates[wallSections[idx].id] = el.classList.contains('collapsed');
            });
            
            const last = wallSections[wallSections.length - 1];
            const newColorIndex = wallSections.length % sectionColors.length;
            const newSection = { 
                id: nextSectionId++,
                name: `Wall ${wallSections.length + 1}`,
                panelCols: last.panelCols, 
                panelRows: last.panelRows, 
                panelWidth: last.panelWidth, 
                panelHeight: last.panelHeight, 
                ledX: last.ledX, 
                ledY: last.ledY, 
                curveIntensity: last.curveIntensity,
                angleOffset: 0,
                color: sectionColors[newColorIndex]
            };
            wallSections.push(newSection);
            
            renderWallSections();
            
            // Restore collapsed states and expand new section
            document.querySelectorAll('.wall-section').forEach((el, idx) => {
                const section = wallSections[idx];
                if (section.id === newSection.id) {
                    el.classList.remove('collapsed'); // New section expanded
                } else if (collapsedStates[section.id] !== undefined) {
                    el.classList.toggle('collapsed', collapsedStates[section.id]);
                }
            });
            
            createLEDWall();
        }

        function deleteSection(id) {
            if (wallSections.length <= 1) return;
            
            // Save collapsed states before re-render
            const collapsedStates = {};
            document.querySelectorAll('.wall-section').forEach((el, idx) => {
                collapsedStates[wallSections[idx].id] = el.classList.contains('collapsed');
            });
            
            wallSections = wallSections.filter(s => s.id !== id);
            renderWallSections();
            
            // Restore collapsed states
            document.querySelectorAll('.wall-section').forEach((el, idx) => {
                const section = wallSections[idx];
                if (collapsedStates[section.id] !== undefined) {
                    el.classList.toggle('collapsed', collapsedStates[section.id]);
                }
            });
            
            createLEDWall();
        }

        function setupUI() {
            renderWallSections();
            // Expand the first section on initial load
            const firstSection = document.querySelector('.wall-section');
            if (firstSection) firstSection.classList.remove('collapsed');
            
            document.getElementById('add-section-btn').addEventListener('click', addSection);

            document.querySelectorAll('.mesh-mode-option').forEach(opt => {
                opt.addEventListener('click', () => {
                    document.querySelectorAll('.mesh-mode-option').forEach(o => o.classList.remove('active'));
                    opt.classList.add('active');
                    meshMode = opt.dataset.mode;
                    createLEDWall();
                });
            });

            document.getElementById('toggle-wireframe').addEventListener('click', function() { this.classList.toggle('active'); wireframeEnabled = this.classList.contains('active'); createLEDWall(); });
            document.getElementById('toggle-frame').addEventListener('click', function() { this.classList.toggle('active'); showFrame = this.classList.contains('active'); createLEDWall(); });
            document.getElementById('toggle-led-sim').addEventListener('click', function() { 
                this.classList.toggle('active'); 
                ledSimEnabled = this.classList.contains('active'); 
                document.getElementById('animation-toggle-container').style.display = ledSimEnabled ? 'flex' : 'none'; 
                // Disable panel IDs if LED sim is enabled
                if (ledSimEnabled && panelIdsEnabled) {
                    panelIdsEnabled = false;
                    document.getElementById('toggle-panel-ids').classList.remove('active');
                    document.getElementById('panel-id-options').style.display = 'none';
                }
                createLEDWall(); 
            });
            document.getElementById('toggle-animation').addEventListener('click', function() { this.classList.toggle('active'); animationEnabled = this.classList.contains('active'); });

            // Panel ID handlers
            document.getElementById('toggle-panel-ids').addEventListener('click', function() { 
                this.classList.toggle('active'); 
                panelIdsEnabled = this.classList.contains('active'); 
                document.getElementById('panel-id-options').style.display = panelIdsEnabled ? 'block' : 'none';
                // Disable LED sim if panel IDs is enabled
                if (panelIdsEnabled && ledSimEnabled) {
                    ledSimEnabled = false;
                    document.getElementById('toggle-led-sim').classList.remove('active');
                    document.getElementById('animation-toggle-container').style.display = 'none';
                }
                createLEDWall(); 
            });
            document.getElementById('panel-border-thickness').addEventListener('change', function() {
                panelBorderThickness = Math.max(1, Math.min(32, parseInt(this.value) || 8));
                this.value = panelBorderThickness;
                if (panelIdsEnabled) createLEDWall();
            });
            document.getElementById('panel-font-size').addEventListener('change', function() {
                panelFontSize = Math.max(0, Math.min(200, parseInt(this.value) || 0));
                this.value = panelFontSize;
                if (panelIdsEnabled) createLEDWall();
            });
            document.getElementById('panel-font-color').addEventListener('input', function() {
                panelIdFontColor = this.value;
                if (panelIdsEnabled) createLEDWall();
            });
            document.getElementById('toggle-section-labels').addEventListener('click', function() {
                this.classList.toggle('active');
                sectionLabelEnabled = this.classList.contains('active');
                if (panelIdsEnabled) createLEDWall();
            });
            document.getElementById('section-label-size').addEventListener('change', function() {
                sectionLabelFontSize = Math.max(0, Math.min(400, parseInt(this.value) || 0));
                this.value = sectionLabelFontSize;
                if (panelIdsEnabled) createLEDWall();
            });
            document.getElementById('section-label-color').addEventListener('input', function() {
                sectionLabelColor = this.value;
                if (panelIdsEnabled) createLEDWall();
            });

            // Camera Frustum Preview handlers
            document.getElementById('toggle-camera-preview').addEventListener('click', function() {
                this.classList.toggle('active');
                cameraPreviewEnabled = this.classList.contains('active');
                document.getElementById('camera-preview-options').style.display = cameraPreviewEnabled ? 'block' : 'none';
                document.getElementById('camera-preview-window').style.display = cameraPreviewEnabled ? 'block' : 'none';
                if (cameraPreviewEnabled) {
                    if (!previewRenderer) initPreviewCamera();
                    resetCameraPosition();
                } else {
                    removeCameraPreview();
                    // Exit pilot mode if active
                    if (pilotMode) {
                        togglePilotMode();
                    }
                    // Deselect camera if selected
                    if (selectedObject === 'camera') {
                        deselectObject();
                    }
                }
            });

            document.getElementById('camera-filmback').addEventListener('change', function() {
                const preset = filmbackPresets[this.value];
                cameraSettings.filmback = this.value;
                if (this.value === 'custom') {
                    document.getElementById('custom-filmback').style.display = 'block';
                } else {
                    document.getElementById('custom-filmback').style.display = 'none';
                    cameraSettings.filmbackWidth = preset.width;
                    cameraSettings.filmbackHeight = preset.height;
                    document.getElementById('filmback-width').value = preset.width;
                    document.getElementById('filmback-height').value = preset.height;
                }
                if (cameraPreviewEnabled) updateCameraFrustum();
            });

            document.getElementById('filmback-width').addEventListener('change', function() {
                cameraSettings.filmbackWidth = Math.max(1, Math.min(100, parseFloat(this.value) || 36));
                this.value = cameraSettings.filmbackWidth;
                if (cameraPreviewEnabled) updateCameraFrustum();
            });

            document.getElementById('filmback-height').addEventListener('change', function() {
                cameraSettings.filmbackHeight = Math.max(1, Math.min(100, parseFloat(this.value) || 24));
                this.value = cameraSettings.filmbackHeight;
                if (cameraPreviewEnabled) updateCameraFrustum();
            });

            document.getElementById('camera-focal-length').addEventListener('change', function() {
                cameraSettings.focalLength = Math.max(8, Math.min(800, parseFloat(this.value) || 35));
                this.value = cameraSettings.focalLength;
                if (cameraPreviewEnabled) updateCameraFrustum();
            });

            document.getElementById('camera-pos-x').addEventListener('change', function() {
                cameraSettings.posX = parseFloat(this.value) || 0;
                if (cameraPreviewEnabled) updateCameraFrustum();
            });

            document.getElementById('camera-pos-y').addEventListener('change', function() {
                cameraSettings.posY = Math.max(0, parseFloat(this.value) || 1.5);
                this.value = cameraSettings.posY;
                if (cameraPreviewEnabled) updateCameraFrustum();
            });

            document.getElementById('camera-pos-z').addEventListener('change', function() {
                cameraSettings.posZ = Math.max(0.1, parseFloat(this.value) || 5);
                this.value = cameraSettings.posZ;
                if (cameraPreviewEnabled) updateCameraFrustum();
            });

            document.getElementById('camera-rot-x').addEventListener('change', function() {
                cameraSettings.rotX = Math.max(-90, Math.min(90, parseFloat(this.value) || 0));
                this.value = cameraSettings.rotX;
                if (cameraPreviewEnabled) updateCameraFrustum();
            });

            document.getElementById('camera-rot-y').addEventListener('change', function() {
                cameraSettings.rotY = Math.max(-180, Math.min(360, parseFloat(this.value) || 0));
                this.value = cameraSettings.rotY;
                if (cameraPreviewEnabled) updateCameraFrustum();
            });

            document.getElementById('camera-rot-z').addEventListener('change', function() {
                cameraSettings.rotZ = Math.max(-180, Math.min(180, parseFloat(this.value) || 0));
                this.value = cameraSettings.rotZ;
                if (cameraPreviewEnabled) updateCameraFrustum();
            });

            document.getElementById('reset-camera').addEventListener('click', resetCameraPosition);

            // Safe distance toggle
            document.getElementById('toggle-safe-distance').addEventListener('click', function() {
                this.classList.toggle('active');
                safeDistanceEnabled = this.classList.contains('active');
                document.getElementById('export-safe-distance').style.display = safeDistanceEnabled ? 'block' : 'none';
                updateSafeDistance();
            });

            document.getElementById('export-safe-distance').addEventListener('click', exportSafeDistanceOBJ);

            // Scene Props handlers
            document.getElementById('toggle-person').addEventListener('click', function() {
                this.classList.toggle('active');
                showPerson = this.classList.contains('active');
                document.getElementById('person-options').style.display = showPerson ? 'block' : 'none';
                if (showPerson) {
                    createPersonMesh();
                } else {
                    removePersonMesh();
                    if (selectedObject === 'person') deselectObject();
                }
            });

            document.getElementById('person-pos-x').addEventListener('change', function() {
                personSettings.posX = parseFloat(this.value) || 0;
                updatePersonTransform();
            });
            document.getElementById('person-pos-z').addEventListener('change', function() {
                personSettings.posZ = parseFloat(this.value) || 0;
                updatePersonTransform();
            });
            document.getElementById('person-rot-y').addEventListener('change', function() {
                personSettings.rotY = Math.max(-180, Math.min(180, parseFloat(this.value) || 0));
                this.value = personSettings.rotY;
                updatePersonTransform();
            });
            document.getElementById('person-scale').addEventListener('change', function() {
                personSettings.scale = Math.max(0.5, Math.min(2, parseFloat(this.value) || 1));
                this.value = personSettings.scale;
                updatePersonTransform();
            });

            document.getElementById('toggle-car').addEventListener('click', function() {
                this.classList.toggle('active');
                showCar = this.classList.contains('active');
                document.getElementById('car-options').style.display = showCar ? 'block' : 'none';
                if (showCar) {
                    createCarMesh();
                } else {
                    removeCarMesh();
                    if (selectedObject === 'car') deselectObject();
                }
            });

            document.getElementById('car-pos-x').addEventListener('change', function() {
                carSettings.posX = parseFloat(this.value) || 0;
                updateCarTransform();
            });
            document.getElementById('car-pos-z').addEventListener('change', function() {
                carSettings.posZ = parseFloat(this.value) || 0;
                updateCarTransform();
            });
            document.getElementById('car-rot-y').addEventListener('change', function() {
                carSettings.rotY = Math.max(-180, Math.min(180, parseFloat(this.value) || 0));
                this.value = carSettings.rotY;
                updateCarTransform();
            });
            document.getElementById('car-scale').addEventListener('change', function() {
                carSettings.scale = Math.max(0.5, Math.min(2, parseFloat(this.value) || 1));
                this.value = carSettings.scale;
                updateCarTransform();
            });

            document.getElementById('view-front').addEventListener('click', () => setView('front'));
            document.getElementById('view-side').addEventListener('click', () => setView('side'));
            document.getElementById('view-top').addEventListener('click', () => setView('top'));
            document.getElementById('view-reset').addEventListener('click', () => setView('reset'));
            document.getElementById('toggle-grid').addEventListener('click', function() {
                this.classList.toggle('active');
                toggleGrid();
            });

            // Gizmo controls
            document.getElementById('gizmo-translate').addEventListener('click', () => setGizmoMode('translate'));
            document.getElementById('gizmo-rotate').addEventListener('click', () => setGizmoMode('rotate'));
            document.getElementById('gizmo-space').addEventListener('click', toggleGizmoSpace);
            document.getElementById('gizmo-pilot').addEventListener('click', togglePilotMode);
            
            // Gizmo keyboard shortcuts
            document.addEventListener('keydown', (e) => {
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
                
                if (e.key.toLowerCase() === 'g') {
                    setGizmoMode('translate');
                } else if (e.key.toLowerCase() === 'r') {
                    setGizmoMode('rotate');
                } else if (e.key.toLowerCase() === 'l') {
                    toggleGizmoSpace();
                } else if (e.key.toLowerCase() === 'p') {
                    togglePilotMode();
                } else if (e.key === 'Escape') {
                    if (pilotMode) {
                        togglePilotMode();
                    } else {
                        deselectObject();
                        if (gizmoMode) {
                            gizmoMode = null;
                            document.getElementById('gizmo-translate').classList.remove('active');
                            document.getElementById('gizmo-rotate').classList.remove('active');
                            createGizmo();
                        }
                    }
                }
            });
            
            // Gizmo mouse handlers
            const canvas = renderer.domElement;
            
            canvas.addEventListener('mousedown', (e) => {
                if (pilotMode) {
                    handlePilotMouseDown(e);
                    return;
                }
                const gizmoHandled = handleGizmoMouseDown(e);
                if (!gizmoHandled && gizmoMode) {
                    handleViewportClick(e);
                }
            });
            
            canvas.addEventListener('mousemove', (e) => {
                if (pilotMode) {
                    handlePilotMouseMove(e);
                    return;
                }
                if (isDraggingGizmo) {
                    handleGizmoMouseMove(e);
                } else {
                    updateGizmoHover(e);
                }
            });
            
            canvas.addEventListener('mouseup', () => {
                if (pilotMode) {
                    handlePilotMouseUp();
                    return;
                }
                handleGizmoMouseUp();
            });
            
            window.addEventListener('mouseup', () => {
                handleGizmoMouseUp();
                handlePilotMouseUp();
            });
            
            canvas.addEventListener('wheel', (e) => {
                if (pilotMode) {
                    handlePilotWheel(e);
                }
            }, { passive: false });

            // Export/Import handlers
            document.getElementById('export-zip').addEventListener('click', exportZIP);
            document.getElementById('export-panel-ids').addEventListener('click', exportPanelIds);
            document.getElementById('export-json').addEventListener('click', exportJSON);
            document.getElementById('export-obj').addEventListener('click', exportOBJ);
            document.getElementById('export-gltf').addEventListener('click', exportGLTF);
            document.getElementById('import-json').addEventListener('click', () => document.getElementById('import-input').click());
            document.getElementById('import-input').addEventListener('change', importJSON);
        }

        async function exportZIP() {
            const zip = new JSZip();
            const scale = 0.001;
            
            // Helper function to sanitize filename
            const sanitizeFilename = (name) => name.replace(/[^a-zA-Z0-9_-]/g, '_');
            
            // Add JSON config
            const jsonData = {
                version: '1.0',
                sections: wallSections.map((s, i) => ({
                    name: s.name || `Wall ${i + 1}`,
                    id: s.id,
                    panel: { columns: s.panelCols, rows: s.panelRows, width_mm: s.panelWidth, height_mm: s.panelHeight },
                    led_resolution: { x: s.ledX, y: s.ledY, pixel_pitch_mm: parseFloat((s.panelWidth / s.ledX).toFixed(2)) },
                    curvature: { 
                        type: s.curveIntensity === 0 ? 'flat' : (s.curveIntensity > 0 ? 'concave' : 'convex'), 
                        angle_degrees: s.curveIntensity 
                    },
                    color: s.color,
                    texture_file: `textures/${sanitizeFilename(s.name || `Wall_${i + 1}`)}_PanelIDs.png`
                })),
                mesh_mode: meshMode,
                totals: {
                    sections: wallSections.length,
                    total_panels: wallSections.reduce((sum, s) => sum + s.panelCols * s.panelRows, 0),
                    total_pixels: wallSections.reduce((sum, s) => sum + s.panelCols * s.panelRows * s.ledX * s.ledY, 0)
                }
            };
            zip.file('led-wall-config.json', JSON.stringify(jsonData, null, 2));

            // Generate OBJ content
            const allSectionsGeometry = generateAllSectionsGeometry(scale);
            const { objContent, mtlContent } = generateOBJContent(allSectionsGeometry, scale);
            zip.file('led-wall-config.obj', objContent);
            zip.file('led-wall-config.mtl', mtlContent);

            // Generate glTF content
            const gltfContent = generateGLTFContent(allSectionsGeometry);
            zip.file('led-wall-config.gltf', JSON.stringify(gltfContent, null, 2));

            // Generate Panel ID textures for each section with cumulative columns
            const texturesFolder = zip.folder('textures');
            let cumulativeCol = 0;
            for (let i = 0; i < wallSections.length; i++) {
                const section = wallSections[i];
                const canvas = createSectionPanelIdCanvas(section, i, null, cumulativeCol);
                const dataUrl = canvas.toDataURL('image/png');
                const base64Data = dataUrl.split(',')[1];
                const filename = `${sanitizeFilename(section.name || `Wall_${i + 1}`)}_PanelIDs.png`;
                texturesFolder.file(filename, base64Data, { base64: true });
                cumulativeCol += section.panelCols;
            }

            // Generate and download ZIP
            const content = await zip.generateAsync({ type: 'blob' });
            const a = document.createElement('a');
            a.href = URL.createObjectURL(content);
            a.download = 'led-wall-export.zip';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(a.href);
        }

        function generateOBJContent(allSectionsGeometry, scale) {
            let objContent = '# LED Wall Configuration OBJ Export\n';
            objContent += `# Mesh Mode: ${meshMode}\n`;
            objContent += '# Generated by LED Wall Configurator\n\n';
            
            let mtlContent = '# LED Wall Materials\n\n';

            if (meshMode === 'combined') {
                const color = new THREE.Color(wallSections[0].color);
                mtlContent += `newmtl LED_Wall_Combined\n`;
                mtlContent += `Kd ${color.r.toFixed(4)} ${color.g.toFixed(4)} ${color.b.toFixed(4)}\n`;
                mtlContent += `Ka 0.1 0.1 0.1\nKs 0.5 0.5 0.5\nNs 100\nd 1.0\n\n`;

                objContent += 'mtllib led-wall-config.mtl\n\n';
                objContent += 'o LED_Wall_Combined\n';
                objContent += 'usemtl LED_Wall_Combined\n';

                let vertexOffset = 1;
                
                allSectionsGeometry.forEach(({ vertices }) => {
                    for (let i = 0; i < vertices.length; i += 3) {
                        objContent += `v ${vertices[i].toFixed(6)} ${vertices[i+1].toFixed(6)} ${vertices[i+2].toFixed(6)}\n`;
                    }
                });

                allSectionsGeometry.forEach(({ section }) => {
                    for (let row = 0; row <= section.panelRows; row++) {
                        for (let col = 0; col <= section.panelCols; col++) {
                            objContent += `vt ${(col / section.panelCols).toFixed(6)} ${(row / section.panelRows).toFixed(6)}\n`;
                        }
                    }
                });

                objContent += 'vn 0 0 1\n';

                allSectionsGeometry.forEach(({ section }) => {
                    const vertsPerRow = section.panelCols + 1;
                    for (let row = 0; row < section.panelRows; row++) {
                        for (let col = 0; col < section.panelCols; col++) {
                            const bl = vertexOffset + row * vertsPerRow + col;
                            const br = bl + 1;
                            const tl = vertexOffset + (row + 1) * vertsPerRow + col;
                            const tr = tl + 1;
                            objContent += `f ${bl}/${bl}/1 ${tl}/${tl}/1 ${tr}/${tr}/1\n`;
                            objContent += `f ${bl}/${bl}/1 ${tr}/${tr}/1 ${br}/${br}/1\n`;
                        }
                    }
                    vertexOffset += (section.panelCols + 1) * (section.panelRows + 1);
                });

            } else if (meshMode === 'section') {
                wallSections.forEach((section, i) => {
                    const color = new THREE.Color(section.color);
                    mtlContent += `newmtl Wall_${i + 1}\n`;
                    mtlContent += `Kd ${color.r.toFixed(4)} ${color.g.toFixed(4)} ${color.b.toFixed(4)}\n`;
                    mtlContent += `Ka 0.1 0.1 0.1\nKs 0.5 0.5 0.5\nNs 100\nd 1.0\n`;
                    mtlContent += `map_Kd textures/Wall_${i + 1}_PanelIDs.png\n\n`;
                });

                objContent += 'mtllib led-wall-config.mtl\n\n';

                let vertexOffset = 1;
                let texCoordOffset = 1;
                let normalOffset = 1;
                
                allSectionsGeometry.forEach(({ section, vertices }, sectionIndex) => {
                    objContent += `o Wall_${sectionIndex + 1}\n`;
                    objContent += `usemtl Wall_${sectionIndex + 1}\n`;

                    for (let i = 0; i < vertices.length; i += 3) {
                        objContent += `v ${vertices[i].toFixed(6)} ${vertices[i+1].toFixed(6)} ${vertices[i+2].toFixed(6)}\n`;
                    }

                    for (let row = 0; row <= section.panelRows; row++) {
                        for (let col = 0; col <= section.panelCols; col++) {
                            objContent += `vt ${(col / section.panelCols).toFixed(6)} ${(row / section.panelRows).toFixed(6)}\n`;
                        }
                    }

                    objContent += `vn 0 0 1\n`;

                    const vertsPerRow = section.panelCols + 1;
                    for (let row = 0; row < section.panelRows; row++) {
                        for (let col = 0; col < section.panelCols; col++) {
                            const bl = vertexOffset + row * vertsPerRow + col;
                            const br = bl + 1;
                            const tl = vertexOffset + (row + 1) * vertsPerRow + col;
                            const tr = tl + 1;
                            const tbl = texCoordOffset + row * vertsPerRow + col;
                            const tbr = tbl + 1;
                            const ttl = texCoordOffset + (row + 1) * vertsPerRow + col;
                            const ttr = ttl + 1;
                            objContent += `f ${bl}/${tbl}/${normalOffset} ${tl}/${ttl}/${normalOffset} ${tr}/${ttr}/${normalOffset}\n`;
                            objContent += `f ${bl}/${tbl}/${normalOffset} ${tr}/${ttr}/${normalOffset} ${br}/${tbr}/${normalOffset}\n`;
                        }
                    }

                    const numVerts = (section.panelCols + 1) * (section.panelRows + 1);
                    vertexOffset += numVerts;
                    texCoordOffset += numVerts;
                    normalOffset += 1;
                    objContent += '\n';
                });

            } else {
                wallSections.forEach((section, i) => {
                    const color = new THREE.Color(section.color);
                    mtlContent += `newmtl Wall_${i + 1}\n`;
                    mtlContent += `Kd ${color.r.toFixed(4)} ${color.g.toFixed(4)} ${color.b.toFixed(4)}\n`;
                    mtlContent += `Ka 0.1 0.1 0.1\nKs 0.5 0.5 0.5\nNs 100\nd 1.0\n\n`;
                });

                objContent += 'mtllib led-wall-config.mtl\n\n';

                let vertexOffset = 1;
                let texCoordOffset = 1;
                let normalOffset = 1;
                
                allSectionsGeometry.forEach(({ section, panelData, panelW, panelH }, sectionIndex) => {
                    panelData.forEach((panel) => {
                        const panelName = `Wall_${sectionIndex + 1}_Panel_R${panel.row + 1}_C${panel.col + 1}`;
                        objContent += `o ${panelName}\n`;
                        objContent += `usemtl Wall_${sectionIndex + 1}\n`;

                        const hw = panelW / 2;
                        const hh = panelH / 2;
                        const cos = Math.cos(panel.rotY);
                        const sin = Math.sin(panel.rotY);

                        const corners = [
                            { x: panel.x + (-hw) * cos, y: panel.y - hh, z: panel.z - (-hw) * sin },
                            { x: panel.x + (hw) * cos,  y: panel.y - hh, z: panel.z - (hw) * sin },
                            { x: panel.x + (hw) * cos,  y: panel.y + hh, z: panel.z - (hw) * sin },
                            { x: panel.x + (-hw) * cos, y: panel.y + hh, z: panel.z - (-hw) * sin }
                        ];

                        corners.forEach(c => {
                            objContent += `v ${c.x.toFixed(6)} ${c.y.toFixed(6)} ${c.z.toFixed(6)}\n`;
                        });

                        objContent += `vt 0 0\nvt 1 0\nvt 1 1\nvt 0 1\n`;

                        const nx = Math.sin(panel.rotY);
                        const nz = Math.cos(panel.rotY);
                        objContent += `vn ${nx.toFixed(6)} 0 ${nz.toFixed(6)}\n`;

                        const v = vertexOffset;
                        const t = texCoordOffset;
                        const n = normalOffset;
                        objContent += `f ${v}/${t}/${n} ${v+3}/${t+3}/${n} ${v+2}/${t+2}/${n}\n`;
                        objContent += `f ${v}/${t}/${n} ${v+2}/${t+2}/${n} ${v+1}/${t+1}/${n}\n`;

                        vertexOffset += 4;
                        texCoordOffset += 4;
                        normalOffset += 1;
                        objContent += '\n';
                    });
                });
            }

            return { objContent, mtlContent };
        }

        function generateGLTFContent(allSectionsGeometry) {
            const gltf = {
                asset: { version: "2.0", generator: "LED Wall Configurator" },
                scene: 0,
                scenes: [{ nodes: [] }],
                nodes: [],
                meshes: [],
                accessors: [],
                bufferViews: [],
                buffers: [],
                materials: []
            };

            const allBufferData = [];
            let byteOffset = 0;
            let accessorIndex = 0;
            let meshIndex = 0;

            function addMesh(name, vertices, indices, color) {
                const materialIndex = gltf.materials.length;
                gltf.materials.push({
                    name: name + "_Material",
                    pbrMetallicRoughness: {
                        baseColorFactor: [color.r, color.g, color.b, 1.0],
                        metallicFactor: 0.0,
                        roughnessFactor: 0.8
                    }
                });

                const vertexBuffer = new Float32Array(vertices);
                const vertexBytes = new Uint8Array(vertexBuffer.buffer);
                allBufferData.push(vertexBytes);
                
                const vertexBufferView = gltf.bufferViews.length;
                gltf.bufferViews.push({
                    buffer: 0,
                    byteOffset: byteOffset,
                    byteLength: vertexBytes.length,
                    target: 34962
                });
                byteOffset += vertexBytes.length;
                const vertPadding = (4 - (byteOffset % 4)) % 4;
                if (vertPadding > 0) {
                    allBufferData.push(new Uint8Array(vertPadding));
                    byteOffset += vertPadding;
                }

                let minX = Infinity, minY = Infinity, minZ = Infinity;
                let maxX = -Infinity, maxY = -Infinity, maxZ = -Infinity;
                for (let i = 0; i < vertices.length; i += 3) {
                    minX = Math.min(minX, vertices[i]);
                    maxX = Math.max(maxX, vertices[i]);
                    minY = Math.min(minY, vertices[i + 1]);
                    maxY = Math.max(maxY, vertices[i + 1]);
                    minZ = Math.min(minZ, vertices[i + 2]);
                    maxZ = Math.max(maxZ, vertices[i + 2]);
                }

                const positionAccessor = accessorIndex++;
                gltf.accessors.push({
                    bufferView: vertexBufferView,
                    byteOffset: 0,
                    componentType: 5126,
                    count: vertices.length / 3,
                    type: "VEC3",
                    min: [minX, minY, minZ],
                    max: [maxX, maxY, maxZ]
                });

                const indexBuffer = new Uint16Array(indices);
                const indexBytes = new Uint8Array(indexBuffer.buffer);
                allBufferData.push(indexBytes);
                
                const indexBufferView = gltf.bufferViews.length;
                gltf.bufferViews.push({
                    buffer: 0,
                    byteOffset: byteOffset,
                    byteLength: indexBytes.length,
                    target: 34963
                });
                byteOffset += indexBytes.length;
                const idxPadding = (4 - (byteOffset % 4)) % 4;
                if (idxPadding > 0) {
                    allBufferData.push(new Uint8Array(idxPadding));
                    byteOffset += idxPadding;
                }

                const indexAccessor = accessorIndex++;
                gltf.accessors.push({
                    bufferView: indexBufferView,
                    byteOffset: 0,
                    componentType: 5123,
                    count: indices.length,
                    type: "SCALAR"
                });

                const currentMeshIndex = meshIndex++;
                gltf.meshes.push({
                    name: name,
                    primitives: [{
                        attributes: { POSITION: positionAccessor },
                        indices: indexAccessor,
                        material: materialIndex
                    }]
                });

                const nodeIndex = gltf.nodes.length;
                gltf.nodes.push({ name: name, mesh: currentMeshIndex });
                gltf.scenes[0].nodes.push(nodeIndex);
            }

            if (meshMode === 'combined') {
                const allVertices = [];
                const allIndices = [];
                let indexOffset = 0;

                allSectionsGeometry.forEach(({ section, vertices }) => {
                    for (let i = 0; i < vertices.length; i++) allVertices.push(vertices[i]);
                    const vertsPerRow = section.panelCols + 1;
                    for (let row = 0; row < section.panelRows; row++) {
                        for (let col = 0; col < section.panelCols; col++) {
                            const bl = indexOffset + row * vertsPerRow + col;
                            const br = bl + 1;
                            const tl = indexOffset + (row + 1) * vertsPerRow + col;
                            const tr = tl + 1;
                            allIndices.push(bl, tl, tr, bl, tr, br);
                        }
                    }
                    indexOffset += (section.panelCols + 1) * (section.panelRows + 1);
                });

                const color = new THREE.Color(wallSections[0].color);
                addMesh('LED_Wall_Combined', allVertices, allIndices, color);

            } else if (meshMode === 'section') {
                allSectionsGeometry.forEach(({ section, vertices }, sectionIndex) => {
                    const indices = [];
                    const vertsPerRow = section.panelCols + 1;
                    for (let row = 0; row < section.panelRows; row++) {
                        for (let col = 0; col < section.panelCols; col++) {
                            const bl = row * vertsPerRow + col;
                            const br = bl + 1;
                            const tl = (row + 1) * vertsPerRow + col;
                            const tr = tl + 1;
                            indices.push(bl, tl, tr, bl, tr, br);
                        }
                    }
                    const color = new THREE.Color(section.color);
                    addMesh(`Wall_${sectionIndex + 1}`, vertices, indices, color);
                });

            } else {
                allSectionsGeometry.forEach(({ section, panelData, panelW, panelH }, sectionIndex) => {
                    const color = new THREE.Color(section.color);

                    panelData.forEach((panel) => {
                        const hw = panelW / 2;
                        const hh = panelH / 2;
                        const cos = Math.cos(panel.rotY);
                        const sin = Math.sin(panel.rotY);

                        const vertices = [
                            panel.x + (-hw) * cos, panel.y - hh, panel.z - (-hw) * sin,
                            panel.x + (hw) * cos,  panel.y - hh, panel.z - (hw) * sin,
                            panel.x + (hw) * cos,  panel.y + hh, panel.z - (hw) * sin,
                            panel.x + (-hw) * cos, panel.y + hh, panel.z - (-hw) * sin
                        ];

                        const indices = [0, 3, 2, 0, 2, 1];
                        const name = `Wall_${sectionIndex + 1}_Panel_R${panel.row + 1}_C${panel.col + 1}`;
                        addMesh(name, vertices, indices, color);
                    });
                });
            }

            const totalLength = allBufferData.reduce((sum, arr) => sum + arr.length, 0);
            const combinedBuffer = new Uint8Array(totalLength);
            let offset = 0;
            for (const arr of allBufferData) {
                combinedBuffer.set(arr, offset);
                offset += arr.length;
            }

            const base64 = btoa(String.fromCharCode(...combinedBuffer));
            gltf.buffers.push({
                byteLength: combinedBuffer.length,
                uri: "data:application/octet-stream;base64," + base64
            });

            return gltf;
        }

        function exportOBJ() {
            const scale = 0.001;
            const allSectionsGeometry = generateAllSectionsGeometry(scale);
            const { objContent, mtlContent } = generateOBJContent(allSectionsGeometry, scale);
            downloadFile(objContent, 'led-wall-config.obj', 'text/plain');
            setTimeout(() => downloadFile(mtlContent, 'led-wall-config.mtl', 'text/plain'), 100);
        }

        function exportGLTF() {
            const scale = 0.001;
            const allSectionsGeometry = generateAllSectionsGeometry(scale);
            const gltfContent = generateGLTFContent(allSectionsGeometry);
            downloadFile(JSON.stringify(gltfContent, null, 2), 'led-wall-config.gltf', 'application/json');
        }

        async function exportPanelIds() {
            // Create a combined canvas with all sections
            const combinedCanvas = createCombinedPanelIdCanvas();
            
            // Convert to blob and download
            combinedCanvas.toBlob((blob) => {
                const a = document.createElement('a');
                a.href = URL.createObjectURL(blob);
                a.download = 'panel-ids.png';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(a.href);
            }, 'image/png');
        }

        function exportJSON() {
            const exportData = {
                version: '1.0',
                sections: wallSections.map((s, i) => ({
                    name: s.name || `Wall ${i + 1}`,
                    id: s.id,
                    panel: { columns: s.panelCols, rows: s.panelRows, width_mm: s.panelWidth, height_mm: s.panelHeight },
                    led_resolution: { x: s.ledX, y: s.ledY, pixel_pitch_mm: parseFloat((s.panelWidth / s.ledX).toFixed(2)) },
                    curvature: { 
                        type: s.curveIntensity === 0 ? 'flat' : (s.curveIntensity > 0 ? 'concave' : 'convex'), 
                        angle_degrees: s.curveIntensity,
                        angle_offset_degrees: s.angleOffset || 0
                    },
                    color: s.color
                })),
                mesh_mode: meshMode,
                totals: {
                    sections: wallSections.length,
                    total_panels: wallSections.reduce((sum, s) => sum + s.panelCols * s.panelRows, 0),
                    total_pixels: wallSections.reduce((sum, s) => sum + s.panelCols * s.panelRows * s.ledX * s.ledY, 0)
                }
            };
            downloadFile(JSON.stringify(exportData, null, 2), 'led-wall-config.json', 'application/json');
        }

        function importJSON(e) {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (event) => {
                try {
                    const data = JSON.parse(event.target.result);
                    if (data.sections && Array.isArray(data.sections)) {
                        wallSections = data.sections.map((s, i) => ({
                            id: s.id !== undefined ? s.id : i,
                            name: s.name || `Wall ${i + 1}`,
                            panelCols: s.panel?.columns || 5,
                            panelRows: s.panel?.rows || 3,
                            panelWidth: s.panel?.width_mm || 500,
                            panelHeight: s.panel?.height_mm || 500,
                            ledX: s.led_resolution?.x || 32,
                            ledY: s.led_resolution?.y || 32,
                            curveIntensity: s.curvature?.angle_degrees || 0,
                            angleOffset: s.curvature?.angle_offset_degrees || 0,
                            color: s.color || sectionColors[i % sectionColors.length]
                        }));
                        nextSectionId = Math.max(...wallSections.map(s => s.id)) + 1;
                        
                        if (data.mesh_mode) {
                            meshMode = data.mesh_mode;
                            document.querySelectorAll('.mesh-mode-option').forEach(o => {
                                o.classList.toggle('active', o.dataset.mode === meshMode);
                            });
                        }
                        
                        renderWallSections();
                        // Expand first section after import
                        const firstSection = document.querySelector('.wall-section');
                        if (firstSection) firstSection.classList.remove('collapsed');
                        createLEDWall();
                    }
                } catch (err) {
                    alert('Error parsing JSON file: ' + err.message);
                }
            };
            reader.readAsText(file);
            e.target.value = ''; // Reset input
        }

        function generateAllSectionsGeometry(scale) {
            const allSectionsGeometry = [];
            let currentX = 0, currentZ = 0, currentAngle = 0;

            wallSections.forEach((section, sectionIndex) => {
                const panelW = section.panelWidth * scale;
                const panelH = section.panelHeight * scale;
                const curveAngleRad = (section.curveIntensity * Math.PI) / 180;
                const isFlat = section.curveIntensity === 0;
                
                // Apply section angle offset
                const angleOffsetRad = ((section.angleOffset || 0) * Math.PI) / 180;
                currentAngle += angleOffsetRad;

                const edgePositions = [{ x: currentX, z: currentZ, angle: currentAngle }];

                for (let col = 0; col < section.panelCols; col++) {
                    if (!isFlat) {
                        currentAngle += curveAngleRad;
                    }

                    const moveDirection = currentAngle;
                    currentX += panelW * Math.cos(moveDirection);
                    currentZ += panelW * Math.sin(moveDirection);
                    
                    edgePositions.push({ x: currentX, z: currentZ, angle: currentAngle });
                }

                // Generate vertices
                const vertices = [];
                for (let row = 0; row <= section.panelRows; row++) {
                    const y = row * panelH;
                    for (let col = 0; col <= section.panelCols; col++) {
                        const edge = edgePositions[col];
                        vertices.push(edge.x, y, edge.z);
                    }
                }

                // Generate panel data for individual panels mode
                const panelData = [];
                for (let row = 0; row < section.panelRows; row++) {
                    const y = row * panelH;
                    for (let col = 0; col < section.panelCols; col++) {
                        const leftEdge = edgePositions[col];
                        const rightEdge = edgePositions[col + 1];
                        const centerX = (leftEdge.x + rightEdge.x) / 2;
                        const centerZ = (leftEdge.z + rightEdge.z) / 2;
                        const centerY = y + panelH / 2;
                        const dx = rightEdge.x - leftEdge.x;
                        const dz = rightEdge.z - leftEdge.z;
                        const rotY = -Math.atan2(dz, dx);

                        panelData.push({ x: centerX, y: centerY, z: centerZ, rotY, col, row });
                    }
                }

                allSectionsGeometry.push({
                    section,
                    sectionIndex,
                    vertices,
                    edgePositions,
                    panelData,
                    panelW,
                    panelH
                });
            });

            return allSectionsGeometry;
        }

        function downloadFile(content, filename, mimeType) {
            const blob = new Blob([content], { type: mimeType });
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(a.href);
        }

        init();
        setupUI();
        setView('reset');
    </script>
</body>
</html>
