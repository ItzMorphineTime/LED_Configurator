<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LED Wall Configurator</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;500;600&family=Outfit:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg-primary: #0a0a0f;
            --bg-secondary: #12121a;
            --bg-tertiary: #1a1a24;
            --accent-cyan: #00f0ff;
            --accent-magenta: #ff00aa;
            --accent-orange: #ff6b35;
            --accent-green: #00ff66;
            --text-primary: #e8e8ec;
            --text-secondary: #8a8a9a;
            --text-dim: #4a4a5a;
            --border-color: #2a2a3a;
            --glow-cyan: 0 0 20px rgba(0, 240, 255, 0.3);
        }

        body {
            font-family: 'Outfit', sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            min-height: 100vh;
            overflow: hidden;
        }

        .app-container {
            display: grid;
            grid-template-columns: 400px 1fr;
            grid-template-rows: 60px 1fr;
            height: 100vh;
        }

        .header {
            grid-column: 1 / -1;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 24px;
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .logo-icon {
            width: 36px;
            height: 36px;
            background: linear-gradient(135deg, var(--accent-cyan), var(--accent-magenta));
            border-radius: 8px;
        }

        .logo-text {
            font-weight: 600;
            font-size: 18px;
        }

        .logo-text span {
            color: var(--accent-cyan);
        }

        .header-stats {
            display: flex;
            gap: 32px;
        }

        .stat {
            text-align: center;
        }

        .stat-value {
            font-family: 'JetBrains Mono', monospace;
            font-size: 18px;
            color: var(--accent-cyan);
            text-shadow: var(--glow-cyan);
        }

        .stat-label {
            font-size: 11px;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-top: 2px;
        }

        .control-panel {
            background: var(--bg-secondary);
            border-right: 1px solid var(--border-color);
            overflow-y: auto;
            padding: 16px;
        }

        .control-panel::-webkit-scrollbar {
            width: 6px;
        }

        .control-panel::-webkit-scrollbar-track {
            background: var(--bg-tertiary);
        }

        .control-panel::-webkit-scrollbar-thumb {
            background: var(--border-color);
            border-radius: 3px;
        }

        .wall-sections {
            display: flex;
            flex-direction: column;
            gap: 12px;
            margin-bottom: 16px;
        }

        .wall-section {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 10px;
            overflow: hidden;
        }

        .wall-section.collapsed .section-content {
            display: none;
        }

        .section-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 14px;
            cursor: pointer;
            background: var(--bg-tertiary);
            border-bottom: 1px solid transparent;
            transition: all 0.2s ease;
        }

        .wall-section:not(.collapsed) .section-header {
            border-bottom-color: var(--border-color);
        }

        .section-header:hover {
            background: rgba(0, 240, 255, 0.05);
        }

        .section-header-left {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .section-color {
            width: 12px;
            height: 12px;
            border-radius: 3px;
        }

        .section-title {
            font-weight: 600;
            font-size: 14px;
        }

        .section-summary {
            font-size: 11px;
            color: var(--text-secondary);
            font-family: 'JetBrains Mono', monospace;
        }

        .section-header-right {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .section-toggle {
            width: 24px;
            height: 24px;
            display: grid;
            place-items: center;
            color: var(--text-secondary);
            transition: transform 0.2s ease;
        }

        .wall-section.collapsed .section-toggle {
            transform: rotate(-90deg);
        }

        .section-delete {
            width: 24px;
            height: 24px;
            display: grid;
            place-items: center;
            color: var(--text-secondary);
            background: transparent;
            border: none;
            cursor: pointer;
            border-radius: 4px;
            transition: all 0.2s ease;
        }

        .section-delete:hover {
            color: #ff4444;
            background: rgba(255, 68, 68, 0.1);
        }

        .section-content {
            padding: 14px;
        }

        .section-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 12px;
        }

        .section-row.single {
            grid-template-columns: 1fr;
        }

        .input-field {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 10px;
            transition: border-color 0.2s ease;
        }

        .input-field:focus-within {
            border-color: var(--accent-cyan);
        }

        .input-field label {
            display: block;
            font-size: 9px;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: var(--text-secondary);
            margin-bottom: 4px;
        }

        .input-field input {
            width: 100%;
            background: transparent;
            border: none;
            color: var(--text-primary);
            font-family: 'JetBrains Mono', monospace;
            font-size: 14px;
            outline: none;
        }

        .curve-hint {
            font-size: 10px;
            color: var(--text-secondary);
            font-style: italic;
            margin-top: 4px;
        }

        .add-section-btn {
            width: 100%;
            padding: 12px;
            background: transparent;
            border: 2px dashed var(--border-color);
            border-radius: 10px;
            color: var(--text-secondary);
            font-family: 'Outfit', sans-serif;
            font-size: 13px;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .add-section-btn:hover {
            border-color: var(--accent-cyan);
            color: var(--accent-cyan);
            background: rgba(0, 240, 255, 0.05);
        }

        .global-section {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 10px;
            padding: 14px;
            margin-bottom: 16px;
        }

        .global-section-title {
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            color: var(--text-secondary);
            margin-bottom: 14px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .global-section-title::before {
            content: '';
            width: 3px;
            height: 12px;
            background: var(--accent-magenta);
            border-radius: 2px;
        }

        .mesh-mode-select {
            display: flex;
            flex-direction: column;
            gap: 6px;
            margin-bottom: 14px;
        }

        .mesh-mode-option {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 12px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .mesh-mode-option:hover {
            border-color: var(--accent-cyan);
        }

        .mesh-mode-option.active {
            background: rgba(0, 240, 255, 0.1);
            border-color: var(--accent-cyan);
        }

        .mesh-mode-option input {
            display: none;
        }

        .mesh-mode-radio {
            width: 16px;
            height: 16px;
            border: 2px solid var(--border-color);
            border-radius: 50%;
            position: relative;
        }

        .mesh-mode-option.active .mesh-mode-radio {
            border-color: var(--accent-cyan);
        }

        .mesh-mode-option.active .mesh-mode-radio::after {
            content: '';
            position: absolute;
            top: 3px;
            left: 3px;
            width: 6px;
            height: 6px;
            background: var(--accent-cyan);
            border-radius: 50%;
        }

        .mesh-mode-label {
            font-size: 12px;
        }

        .toggle-container {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 10px 0;
        }

        .toggle-label {
            font-size: 13px;
        }

        .toggle {
            width: 44px;
            height: 24px;
            background: var(--bg-primary);
            border-radius: 12px;
            cursor: pointer;
            position: relative;
            transition: background 0.3s ease;
        }

        .toggle.active {
            background: var(--accent-cyan);
        }

        .toggle::after {
            content: '';
            position: absolute;
            width: 18px;
            height: 18px;
            background: white;
            border-radius: 50%;
            top: 3px;
            left: 3px;
            transition: transform 0.3s ease;
        }

        .toggle.active::after {
            transform: translateX(20px);
        }

        .export-btn {
            width: 100%;
            padding: 14px;
            background: linear-gradient(135deg, var(--accent-cyan), var(--accent-magenta));
            border: none;
            border-radius: 8px;
            color: white;
            font-family: 'Outfit', sans-serif;
            font-size: 13px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .export-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 30px rgba(0, 240, 255, 0.3);
        }

        .viewport {
            position: relative;
            background: var(--bg-primary);
            overflow: hidden;
        }

        #three-canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        .viewport-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
        }

        .grid-lines {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-image: 
                linear-gradient(rgba(0, 240, 255, 0.03) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 240, 255, 0.03) 1px, transparent 1px);
            background-size: 50px 50px;
        }

        .viewport-info {
            position: absolute;
            bottom: 20px;
            left: 20px;
        }

        .info-badge {
            background: rgba(18, 18, 26, 0.9);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 8px 12px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 11px;
            color: var(--text-secondary);
        }

        .viewport-controls {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .view-btn {
            width: 40px;
            height: 40px;
            background: rgba(18, 18, 26, 0.9);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            cursor: pointer;
            display: grid;
            place-items: center;
            transition: all 0.2s ease;
            color: var(--text-secondary);
        }

        .view-btn:hover {
            border-color: var(--accent-cyan);
            color: var(--accent-cyan);
        }

        .view-btn svg {
            width: 18px;
            height: 18px;
        }

        .section-color-0 { background: #00f0ff; }
        .section-color-1 { background: #ff00aa; }
        .section-color-2 { background: #00ff66; }
        .section-color-3 { background: #ff6b35; }
        .section-color-4 { background: #ffdd00; }
        .section-color-5 { background: #aa66ff; }
        .section-color-6 { background: #66ffaa; }
        .section-color-7 { background: #ff6666; }

        .section-color-picker {
            display: flex;
            gap: 6px;
            align-items: center;
            margin-top: 6px;
        }

        .color-swatch-small {
            width: 24px;
            height: 24px;
            border-radius: 4px;
            cursor: pointer;
            border: 2px solid transparent;
            transition: all 0.2s ease;
        }

        .color-swatch-small:hover {
            transform: scale(1.1);
        }

        .color-swatch-small.active {
            border-color: white;
            box-shadow: 0 0 8px currentColor;
        }

        .color-input-custom {
            width: 28px;
            height: 24px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            background: transparent;
            padding: 0;
        }

        .color-input-custom::-webkit-color-swatch-wrapper {
            padding: 0;
        }

        .color-input-custom::-webkit-color-swatch {
            border: 1px solid var(--border-color);
            border-radius: 4px;
        }

        .section-warning {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 10px 12px;
            background: rgba(255, 107, 53, 0.15);
            border: 1px solid rgba(255, 107, 53, 0.4);
            border-radius: 6px;
            margin-bottom: 12px;
            color: #ff6b35;
            font-size: 11px;
        }

        .section-warning svg {
            flex-shrink: 0;
            stroke: #ff6b35;
        }

        .warning-indicator {
            color: #ff6b35;
            font-size: 12px;
        }

        .export-section {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .export-row {
            display: flex;
            gap: 8px;
        }

        .export-btn {
            flex: 1;
            padding: 12px;
            background: linear-gradient(135deg, var(--accent-cyan), var(--accent-magenta));
            border: none;
            border-radius: 8px;
            color: white;
            font-family: 'Outfit', sans-serif;
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .export-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 30px rgba(0, 240, 255, 0.3);
        }

        .export-btn.secondary {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
        }

        .export-btn.secondary:hover {
            border-color: var(--accent-cyan);
            box-shadow: 0 5px 20px rgba(0, 240, 255, 0.2);
        }

        .import-input {
            display: none;
        }

        @media (max-width: 900px) {
            .app-container {
                grid-template-columns: 1fr;
                grid-template-rows: 60px 1fr 350px;
            }
            .control-panel {
                order: 3;
                border-right: none;
                border-top: 1px solid var(--border-color);
            }
        }
    </style>
</head>
<body>
    <div class="app-container">
        <header class="header">
            <div class="logo">
                <div class="logo-icon"></div>
                <div class="logo-text">LED<span>WALL</span> Configurator</div>
            </div>
            <div class="header-stats">
                <div class="stat">
                    <div class="stat-value" id="total-pixels">0</div>
                    <div class="stat-label">Total Pixels</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="total-panels">0</div>
                    <div class="stat-label">Panels</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="total-sections">0</div>
                    <div class="stat-label">Sections</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="total-arc">0°</div>
                    <div class="stat-label">Total Arc</div>
                </div>
            </div>
        </header>

        <aside class="control-panel">
            <div class="wall-sections" id="wall-sections"></div>

            <button class="add-section-btn" id="add-section-btn">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <line x1="12" y1="5" x2="12" y2="19"></line>
                    <line x1="5" y1="12" x2="19" y2="12"></line>
                </svg>
                Add Wall Section
            </button>

            <div class="global-section" style="margin-top: 16px;">
                <div class="global-section-title">Mesh Options</div>
                <div class="mesh-mode-select" id="mesh-mode-select">
                    <label class="mesh-mode-option active" data-mode="combined">
                        <input type="radio" name="mesh-mode" value="combined" checked>
                        <span class="mesh-mode-radio"></span>
                        <span class="mesh-mode-label">Single Combined Mesh</span>
                    </label>
                    <label class="mesh-mode-option" data-mode="section">
                        <input type="radio" name="mesh-mode" value="section">
                        <span class="mesh-mode-radio"></span>
                        <span class="mesh-mode-label">Individual Section Meshes</span>
                    </label>
                    <label class="mesh-mode-option" data-mode="panel">
                        <input type="radio" name="mesh-mode" value="panel">
                        <span class="mesh-mode-radio"></span>
                        <span class="mesh-mode-label">Individual Panels</span>
                    </label>
                </div>
                <div class="toggle-container">
                    <span class="toggle-label">Wireframe</span>
                    <div class="toggle" id="toggle-wireframe"></div>
                </div>
                <div class="toggle-container">
                    <span class="toggle-label">Show Panel Frames</span>
                    <div class="toggle" id="toggle-frame"></div>
                </div>
            </div>

            <div class="global-section">
                <div class="global-section-title">Display</div>
                <div class="toggle-container">
                    <span class="toggle-label">Simulate LED Pixels</span>
                    <div class="toggle" id="toggle-led-sim"></div>
                </div>
                <div class="toggle-container" id="animation-toggle-container" style="display: none;">
                    <span class="toggle-label">Animate LEDs</span>
                    <div class="toggle" id="toggle-animation"></div>
                </div>
            </div>

            <div class="global-section">
                <div class="global-section-title">Panel IDs</div>
                <div class="toggle-container">
                    <span class="toggle-label">Show Panel Labels</span>
                    <div class="toggle" id="toggle-panel-ids"></div>
                </div>
                <div id="panel-id-options" style="display: none;">
                    <div class="input-field" style="margin-top: 10px;">
                        <label>Border Thickness (px)</label>
                        <input type="number" id="panel-border-thickness" value="8" min="1" max="32">
                    </div>
                    <div class="input-field" style="margin-top: 10px;">
                        <label>Label Font Size (0=auto)</label>
                        <input type="number" id="panel-font-size" value="0" min="0" max="200">
                    </div>
                    <div class="input-field" style="margin-top: 10px;">
                        <label>Label Font Color</label>
                        <input type="color" id="panel-font-color" value="#ffffff" style="width: 100%; height: 30px; cursor: pointer;">
                    </div>
                    <div class="toggle-container" style="margin-top: 10px;">
                        <span class="toggle-label">Show Section Names</span>
                        <div class="toggle active" id="toggle-section-labels"></div>
                    </div>
                    <div class="input-field" style="margin-top: 10px;">
                        <label>Section Label Size (0=auto)</label>
                        <input type="number" id="section-label-size" value="0" min="0" max="400">
                    </div>
                    <div class="input-field" style="margin-top: 10px;">
                        <label>Section Label Color</label>
                        <input type="color" id="section-label-color" value="#888888" style="width: 100%; height: 30px; cursor: pointer;">
                    </div>
                </div>
            </div>

            <div class="export-section">
                <div class="export-row">
                    <button class="export-btn" id="export-zip">Export All (ZIP)</button>
                </div>
                <div class="export-row">
                    <button class="export-btn secondary" id="export-panel-ids">Export Panel IDs</button>
                </div>
                <div class="export-row">
                    <button class="export-btn secondary" id="export-json">Export JSON</button>
                    <button class="export-btn secondary" id="import-json">Import JSON</button>
                </div>
                <div class="export-row">
                    <button class="export-btn secondary" id="export-obj">Export OBJ</button>
                    <button class="export-btn secondary" id="export-gltf">Export glTF</button>
                </div>
                <input type="file" id="import-input" class="import-input" accept=".json">
            </div>
        </aside>

        <main class="viewport">
            <canvas id="three-canvas"></canvas>
            <div class="viewport-controls">
                <button class="view-btn" id="view-front" title="Front View">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <rect x="3" y="3" width="18" height="18" rx="2"/>
                    </svg>
                </button>
                <button class="view-btn" id="view-side" title="Side View">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M12 3v18M3 12h18"/>
                    </svg>
                </button>
                <button class="view-btn" id="view-top" title="Top View">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <circle cx="12" cy="12" r="9"/>
                        <circle cx="12" cy="12" r="3"/>
                    </svg>
                </button>
                <button class="view-btn" id="view-reset" title="Reset View">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/>
                        <path d="M3 3v5h5"/>
                    </svg>
                </button>
            </div>
            <div class="viewport-overlay">
                <div class="grid-lines"></div>
                <div class="viewport-info">
                    <div class="info-badge">Drag to rotate • Scroll to zoom, WASD to move, EQ to go up and down</div>
                </div>
            </div>
        </main>
    </div>

    <script>
        let scene, camera, renderer, ledWallGroup, frameGroup;
        let animationEnabled = false;
        let showFrame = false;
        let wireframeEnabled = false;
        let ledSimEnabled = false;
        let meshMode = 'combined';
        let animationTime = 0;
        
        // Panel ID settings
        let panelIdsEnabled = false;
        let panelBorderThickness = 8;
        let panelFontSize = 0; // 0 = auto

        const sectionColors = [
            '#00f0ff', '#ff00aa', '#00ff66', '#ff6b35',
            '#ffdd00', '#aa66ff', '#66ffaa', '#ff6666'
        ];
        
        const panelBorderColors = ['#ff0000', '#00ff00', '#0000ff']; // R, G, B cycle

        // Panel ID customization
        let panelIdFontColor = '#ffffff';
        let sectionLabelEnabled = true;
        let sectionLabelFontSize = 0; // 0 = auto
        let sectionLabelColor = '#888888';

        let wallSections = [{
            id: 0,
            name: 'Wall 1',
            panelCols: 5,
            panelRows: 3,
            panelWidth: 500,
            panelHeight: 500,
            ledX: 32,
            ledY: 32,
            curveIntensity: 0,
            color: '#00f0ff'
        }];

        let nextSectionId = 1;

        function init() {
            const canvas = document.getElementById('three-canvas');
            const container = canvas.parentElement;

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0a0f);

            camera = new THREE.PerspectiveCamera(50, container.clientWidth / container.clientHeight, 0.1, 1000);
            camera.position.set(0, 0, 8);

            renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

            scene.add(new THREE.AmbientLight(0xffffff, 0.3));
            const pointLight = new THREE.PointLight(0xffffff, 0.8);
            pointLight.position.set(5, 5, 10);
            scene.add(pointLight);

            const gridHelper = new THREE.GridHelper(20, 20, 0x1a1a24, 0x1a1a24);
            gridHelper.rotation.x = Math.PI / 2;
            gridHelper.position.z = -0.1;
            scene.add(gridHelper);
            scene.add(new THREE.AxesHelper(0.5));

            createLEDWall();
            setupControls();
            window.addEventListener('resize', onResize);
            animate();
        }

        function createLEDWall() {
            if (ledWallGroup) {
                scene.remove(ledWallGroup);
                ledWallGroup.traverse((child) => {
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) {
                        if (Array.isArray(child.material)) child.material.forEach(m => m.dispose());
                        else child.material.dispose();
                    }
                });
            }
            if (frameGroup) {
                scene.remove(frameGroup);
                frameGroup.traverse((child) => {
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) child.material.dispose();
                });
            }

            ledWallGroup = new THREE.Group();
            frameGroup = new THREE.Group();

            const scale = 0.002;
            let allSectionsData = [];
            
            // Track cumulative position and angle across sections
            let currentX = 0;
            let currentZ = 0;
            let currentAngle = 0;

            wallSections.forEach((section, sectionIndex) => {
                const panelW = section.panelWidth * scale;
                const panelH = section.panelHeight * scale;
                const curveAngleRad = (Math.abs(section.curveIntensity) * Math.PI) / 180;
                const isFlat = section.curveIntensity === 0;
                const dirMult = section.curveIntensity > 0 ? 1 : (section.curveIntensity < 0 ? -1 : 0);

                const edgePositions = [];
                const panelData = [];

                // First edge starts at current position with inherited angle
                edgePositions.push({ x: currentX, z: currentZ, angle: currentAngle });

                for (let col = 0; col < section.panelCols; col++) {
                    // Apply curve BEFORE movement (so first panel is also curved)
                    if (!isFlat) {
                        currentAngle += curveAngleRad;
                    }

                    // Move in the direction of current angle
                    const moveAngle = currentAngle * (dirMult !== 0 ? dirMult : 1);
                    
                    if (isFlat && edgePositions[0].angle === 0 && edgePositions.length === 1) {
                        // Pure flat section starting from origin, no inherited angle
                        currentX += panelW;
                    } else {
                        // Curved or flat with inherited angle
                        currentX += panelW * Math.cos(moveAngle);
                        currentZ += panelW * Math.sin(moveAngle);
                    }

                    edgePositions.push({ x: currentX, z: currentZ, angle: currentAngle });
                }

                // Calculate panel centers
                for (let row = 0; row < section.panelRows; row++) {
                    const y = row * panelH;

                    for (let col = 0; col < section.panelCols; col++) {
                        const leftEdge = edgePositions[col];
                        const rightEdge = edgePositions[col + 1];

                        const centerX = (leftEdge.x + rightEdge.x) / 2;
                        const centerZ = (leftEdge.z + rightEdge.z) / 2;
                        const centerY = y + panelH / 2;

                        const dx = rightEdge.x - leftEdge.x;
                        const dz = rightEdge.z - leftEdge.z;
                        const rotY = -Math.atan2(dz, dx);

                        panelData.push({
                            x: centerX, y: centerY, z: centerZ,
                            rotY, col, row, sectionIndex
                        });
                    }
                }

                allSectionsData.push({
                    section, sectionIndex, edgePositions, panelData,
                    panelW, panelH, dirMult, isFlat
                });
            });

            if (meshMode === 'combined') {
                createCombinedMesh(allSectionsData);
            } else if (meshMode === 'section') {
                createSectionMeshes(allSectionsData);
            } else {
                createIndividualPanels(allSectionsData);
            }

            if (showFrame) {
                allSectionsData.forEach(({ panelData, panelW, panelH }) => {
                    panelData.forEach((data) => {
                        const frameGeometry = new THREE.EdgesGeometry(new THREE.BoxGeometry(panelW, panelH, 0.02));
                        const frame = new THREE.LineSegments(frameGeometry, new THREE.LineBasicMaterial({ color: 0x4a4a5a }));
                        frame.position.set(data.x, data.y, data.z);
                        frame.rotation.y = data.rotY;
                        frameGroup.add(frame);
                    });
                });
            }

            scene.add(ledWallGroup);
            if (showFrame) scene.add(frameGroup);

            updateStats();
            updateCameraPosition();
        }

        function createCombinedMesh(allSectionsData) {
            const vertPositions = [];
            const vertNormals = [];
            const vertUvs = [];
            const indices = [];
            let vertexOffset = 0;

            let totalLedX = 0, totalLedY = 0;
            wallSections.forEach(s => {
                totalLedX += s.panelCols * s.ledX;
                totalLedY = Math.max(totalLedY, s.panelRows * s.ledY);
            });

            let uvOffsetX = 0;

            allSectionsData.forEach(({ section, edgePositions, panelW, panelH, dirMult, isFlat }) => {
                const sectionLedX = section.panelCols * section.ledX;
                const uvWidth = sectionLedX / totalLedX;

                for (let row = 0; row <= section.panelRows; row++) {
                    const y = row * panelH;
                    for (let col = 0; col <= section.panelCols; col++) {
                        const edge = edgePositions[col];
                        vertPositions.push(edge.x, y, edge.z);

                        const nx = isFlat ? 0 : Math.sin(edge.angle * dirMult);
                        const nz = isFlat ? 1 : Math.cos(edge.angle * dirMult);
                        vertNormals.push(nx, 0, nz);

                        vertUvs.push(uvOffsetX + (col / section.panelCols) * uvWidth, row / section.panelRows);
                    }
                }

                const vertsPerRow = section.panelCols + 1;
                for (let row = 0; row < section.panelRows; row++) {
                    for (let col = 0; col < section.panelCols; col++) {
                        const bl = vertexOffset + row * vertsPerRow + col;
                        const br = bl + 1;
                        const tl = vertexOffset + (row + 1) * vertsPerRow + col;
                        const tr = tl + 1;
                        indices.push(bl, tl, tr, bl, tr, br);
                    }
                }

                vertexOffset += (section.panelCols + 1) * (section.panelRows + 1);
                uvOffsetX += uvWidth;
            });

            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertPositions, 3));
            geometry.setAttribute('normal', new THREE.Float32BufferAttribute(vertNormals, 3));
            geometry.setAttribute('uv', new THREE.Float32BufferAttribute(vertUvs, 2));
            geometry.setIndex(indices);

            // For combined mesh, use vertex colors to support multiple section colors
            const colors = [];
            allSectionsData.forEach(({ section }) => {
                const color = new THREE.Color(section.color);
                for (let row = 0; row <= section.panelRows; row++) {
                    for (let col = 0; col <= section.panelCols; col++) {
                        colors.push(color.r, color.g, color.b);
                    }
                }
            });
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

            let material;
            if (panelIdsEnabled) {
                // Create combined panel ID texture
                const combinedCanvas = createCombinedPanelIdCanvas();
                const texture = new THREE.CanvasTexture(combinedCanvas);
                texture.needsUpdate = true;
                material = new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide, wireframe: wireframeEnabled });
            } else if (ledSimEnabled) {
                material = new THREE.MeshBasicMaterial({ map: createLEDTexture(totalLedX, totalLedY, wallSections[0].color), side: THREE.DoubleSide, wireframe: wireframeEnabled });
            } else {
                material = new THREE.MeshBasicMaterial({ vertexColors: true, side: THREE.DoubleSide, wireframe: wireframeEnabled });
            }

            ledWallGroup.add(new THREE.Mesh(geometry, material));
        }

        function createCombinedPanelIdCanvas() {
            let totalLedX = 0, totalLedY = 0;
            wallSections.forEach(s => {
                totalLedX += s.panelCols * s.ledX;
                totalLedY = Math.max(totalLedY, s.panelRows * s.ledY);
            });

            const scale = Math.max(1, Math.min(4, Math.floor(4096 / Math.max(totalLedX, totalLedY))));
            const canvas = document.createElement('canvas');
            canvas.width = totalLedX * scale;
            canvas.height = totalLedY * scale;
            const ctx = canvas.getContext('2d');

            ctx.fillStyle = '#0a0a0f';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            let xOffset = 0;
            let cumulativeCol = 0;
            wallSections.forEach((section, sectionIndex) => {
                const sectionCanvas = createSectionPanelIdCanvas(section, sectionIndex, scale, cumulativeCol);
                // Draw section canvas at correct position, accounting for different heights
                const yOffset = (totalLedY - section.panelRows * section.ledY) * scale;
                ctx.drawImage(sectionCanvas, xOffset * scale, yOffset);
                xOffset += section.panelCols * section.ledX;
                cumulativeCol += section.panelCols;
            });

            return canvas;
        }

        function createSectionMeshes(allSectionsData) {
            let cumulativeCol = 0;
            allSectionsData.forEach(({ section, sectionIndex, edgePositions, panelW, panelH, dirMult, isFlat }) => {
                const vertPositions = [], vertNormals = [], vertUvs = [], indices = [];
                const sectionColor = new THREE.Color(section.color);

                for (let row = 0; row <= section.panelRows; row++) {
                    const y = row * panelH;
                    for (let col = 0; col <= section.panelCols; col++) {
                        const edge = edgePositions[col];
                        vertPositions.push(edge.x, y, edge.z);
                        vertNormals.push(isFlat ? 0 : Math.sin(edge.angle * dirMult), 0, isFlat ? 1 : Math.cos(edge.angle * dirMult));
                        vertUvs.push(col / section.panelCols, row / section.panelRows);
                    }
                }

                const vertsPerRow = section.panelCols + 1;
                for (let row = 0; row < section.panelRows; row++) {
                    for (let col = 0; col < section.panelCols; col++) {
                        const bl = row * vertsPerRow + col, br = bl + 1;
                        const tl = (row + 1) * vertsPerRow + col, tr = tl + 1;
                        indices.push(bl, tl, tr, bl, tr, br);
                    }
                }

                const geometry = new THREE.BufferGeometry();
                geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertPositions, 3));
                geometry.setAttribute('normal', new THREE.Float32BufferAttribute(vertNormals, 3));
                geometry.setAttribute('uv', new THREE.Float32BufferAttribute(vertUvs, 2));
                geometry.setIndex(indices);

                let material;
                if (panelIdsEnabled) {
                    const panelIdCanvas = createSectionPanelIdCanvas(section, sectionIndex, null, cumulativeCol);
                    const texture = new THREE.CanvasTexture(panelIdCanvas);
                    texture.needsUpdate = true;
                    material = new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide, wireframe: wireframeEnabled });
                } else if (ledSimEnabled) {
                    material = new THREE.MeshBasicMaterial({ map: createLEDTexture(section.panelCols * section.ledX, section.panelRows * section.ledY, section.color), side: THREE.DoubleSide, wireframe: wireframeEnabled });
                } else {
                    material = new THREE.MeshBasicMaterial({ color: sectionColor, side: THREE.DoubleSide, wireframe: wireframeEnabled });
                }

                ledWallGroup.add(new THREE.Mesh(geometry, material));
                cumulativeCol += section.panelCols;
            });
        }

        function createIndividualPanels(allSectionsData) {
            let cumulativeCol = 0;
            allSectionsData.forEach(({ section, sectionIndex, panelData, panelW, panelH }) => {
                const sectionColor = new THREE.Color(section.color);
                
                panelData.forEach((data) => {
                    const geometry = new THREE.PlaneGeometry(panelW, panelH);
                    let material;
                    
                    if (panelIdsEnabled) {
                        // Use cumulative column for sequential labeling across all sections
                        const { texture } = createPanelIdTexture(cumulativeCol + data.col, data.row, sectionIndex, section.ledX, section.ledY, section);
                        material = new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide, wireframe: wireframeEnabled });
                    } else if (ledSimEnabled) {
                        material = new THREE.MeshBasicMaterial({ map: createLEDTexture(section.ledX, section.ledY, section.color), side: THREE.DoubleSide, wireframe: wireframeEnabled });
                    } else {
                        material = new THREE.MeshBasicMaterial({ color: sectionColor, side: THREE.DoubleSide, wireframe: wireframeEnabled });
                    }

                    const panel = new THREE.Mesh(geometry, material);
                    panel.position.set(data.x, data.y, data.z);
                    panel.rotation.y = data.rotY;
                    ledWallGroup.add(panel);
                });
                cumulativeCol += section.panelCols;
            });
        }

        function createLEDTexture(ledX, ledY, color) {
            const ledColor = new THREE.Color(color);
            const canvas = document.createElement('canvas');
            const maxDim = 4096;
            const pixelSize = Math.max(4, Math.min(16, Math.floor(maxDim / Math.max(ledX, ledY))));
            canvas.width = Math.min(maxDim, ledX * pixelSize);
            canvas.height = Math.min(maxDim, ledY * pixelSize);
            const ctx = canvas.getContext('2d');

            ctx.fillStyle = '#0a0a0f';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const pixelW = canvas.width / ledX, pixelH = canvas.height / ledY;
            const ledRadius = Math.min(pixelW, pixelH) * 0.35;

            for (let y = 0; y < ledY; y++) {
                for (let x = 0; x < ledX; x++) {
                    const cx = (x + 0.5) * pixelW, cy = (y + 0.5) * pixelH;

                    const gradient = ctx.createRadialGradient(cx, cy, 0, cx, cy, ledRadius * 1.5);
                    gradient.addColorStop(0, `rgba(${ledColor.r * 255}, ${ledColor.g * 255}, ${ledColor.b * 255}, 1)`);
                    gradient.addColorStop(0.5, `rgba(${ledColor.r * 255}, ${ledColor.g * 255}, ${ledColor.b * 255}, 0.5)`);
                    gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(cx, cy, ledRadius * 1.5, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.fillStyle = `rgb(${ledColor.r * 255}, ${ledColor.g * 255}, ${ledColor.b * 255})`;
                    ctx.beginPath();
                    ctx.arc(cx, cy, ledRadius * 0.7, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;
            return texture;
        }

        function getColumnLabel(index) {
            let label = '';
            let idx = index;
            do {
                label = String.fromCharCode(65 + (idx % 26)) + label;
                idx = Math.floor(idx / 26) - 1;
            } while (idx >= 0);
            return label;
        }

        function createPanelIdTexture(col, row, sectionIndex, ledX, ledY, section) {
            const canvas = document.createElement('canvas');
            const scale = Math.max(4, Math.min(16, Math.floor(4096 / Math.max(ledX, ledY))));
            canvas.width = ledX * scale;
            canvas.height = ledY * scale;
            const ctx = canvas.getContext('2d');

            // Background
            ctx.fillStyle = '#0a0a0f';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Border with RGB cycling based on (col + row) % 3
            const borderColorIndex = (col + row) % 3;
            const borderColor = panelBorderColors[borderColorIndex];
            const borderThickness = panelBorderThickness * scale / 4;
            
            ctx.strokeStyle = borderColor;
            ctx.lineWidth = borderThickness;
            ctx.strokeRect(borderThickness / 2, borderThickness / 2, canvas.width - borderThickness, canvas.height - borderThickness);

            // Label
            const colLabel = getColumnLabel(col);
            const rowLabel = (row + 1).toString();
            const label = `${colLabel}${rowLabel}`;

            // Font size: auto or fixed
            let fontSize = panelFontSize * scale / 4;
            if (fontSize === 0) {
                // Auto size based on canvas dimensions
                fontSize = Math.min(canvas.width, canvas.height) * 0.4;
            }

            ctx.fillStyle = panelIdFontColor;
            ctx.font = `bold ${fontSize}px 'JetBrains Mono', monospace`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(label, canvas.width / 2, canvas.height / 2);

            // Section name indicator (small text at bottom) if enabled
            if (sectionLabelEnabled && section && section.name) {
                const sectionFontSize = fontSize * 0.25;
                ctx.font = `${sectionFontSize}px 'JetBrains Mono', monospace`;
                ctx.fillStyle = sectionLabelColor;
                ctx.fillText(section.name, canvas.width / 2, canvas.height - borderThickness - sectionFontSize);
            }

            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;
            return { texture, canvas };
        }

        function createSectionPanelIdCanvas(section, sectionIndex, overrideScale, startCol = 0) {
            // Create a single canvas for the entire section with all panel IDs
            const canvasWidth = section.panelCols * section.ledX;
            const canvasHeight = section.panelRows * section.ledY;
            const scale = overrideScale || Math.max(1, Math.min(4, Math.floor(4096 / Math.max(canvasWidth, canvasHeight))));
            
            const canvas = document.createElement('canvas');
            canvas.width = canvasWidth * scale;
            canvas.height = canvasHeight * scale;
            const ctx = canvas.getContext('2d');

            // Background
            ctx.fillStyle = '#0a0a0f';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const panelW = section.ledX * scale;
            const panelH = section.ledY * scale;
            const borderThickness = panelBorderThickness * scale / 4;

            for (let row = 0; row < section.panelRows; row++) {
                for (let col = 0; col < section.panelCols; col++) {
                    const x = col * panelW;
                    const y = (section.panelRows - 1 - row) * panelH; // Flip Y for texture coords

                    // Border with RGB cycling (use cumulative column for consistent pattern)
                    const borderColorIndex = ((startCol + col) + row) % 3;
                    ctx.strokeStyle = panelBorderColors[borderColorIndex];
                    ctx.lineWidth = borderThickness;
                    ctx.strokeRect(x + borderThickness / 2, y + borderThickness / 2, panelW - borderThickness, panelH - borderThickness);

                    // Label with cumulative column numbering
                    const colLabel = getColumnLabel(startCol + col);
                    const label = `${colLabel}${row + 1}`;

                    let fontSize = panelFontSize * scale / 4;
                    if (fontSize === 0) {
                        fontSize = Math.min(panelW, panelH) * 0.35;
                    }

                    ctx.fillStyle = panelIdFontColor;
                    ctx.font = `bold ${fontSize}px 'JetBrains Mono', monospace`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(label, x + panelW / 2, y + panelH / 2);
                }
            }

            // Draw section name in center if enabled
            if (sectionLabelEnabled && section.name) {
                let sectionFontSize = sectionLabelFontSize * scale / 4;
                if (sectionFontSize === 0) {
                    sectionFontSize = Math.min(canvas.width, canvas.height) * 0.15;
                }
                
                ctx.fillStyle = sectionLabelColor;
                ctx.font = `bold ${sectionFontSize}px 'Outfit', sans-serif`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.globalAlpha = 0.6;
                ctx.fillText(section.name, canvas.width / 2, canvas.height / 2);
                ctx.globalAlpha = 1.0;
            }

            return canvas;
        }

        function updateStats() {
            let totalPixels = 0, totalPanels = 0, totalArc = 0;
            wallSections.forEach(s => {
                totalPixels += s.panelCols * s.panelRows * s.ledX * s.ledY;
                totalPanels += s.panelCols * s.panelRows;
                totalArc += s.panelCols * Math.abs(s.curveIntensity);
            });
            document.getElementById('total-pixels').textContent = totalPixels.toLocaleString();
            document.getElementById('total-panels').textContent = totalPanels;
            document.getElementById('total-sections').textContent = wallSections.length;
            document.getElementById('total-arc').textContent = `${totalArc.toFixed(1)}°`;
        }

        let isDragging = false, previousMousePosition = { x: 0, y: 0 };
        let cameraAngle = { theta: 0, phi: Math.PI / 2 }, cameraDistance = 8;
        let targetPosition = new THREE.Vector3(0, 0, 0);
        let sceneOffset = new THREE.Vector3(0, 0, 0);

        function updateTargetPosition() {
            const scale = 0.002;
            let totalWidth = 0, maxHeight = 0;
            wallSections.forEach(s => {
                totalWidth += s.panelCols * s.panelWidth * scale;
                maxHeight = Math.max(maxHeight, s.panelRows * s.panelHeight * scale);
            });
            targetPosition.set(totalWidth / 2, maxHeight / 2, 0).add(sceneOffset);
        }

        function setupControls() {
            const canvas = renderer.domElement;
            canvas.addEventListener('mousedown', (e) => { isDragging = true; previousMousePosition = { x: e.clientX, y: e.clientY }; });
            canvas.addEventListener('mousemove', (e) => {
                if (!isDragging) return;
                cameraAngle.theta -= (e.clientX - previousMousePosition.x) * 0.01;
                cameraAngle.phi = Math.max(0.1, Math.min(Math.PI - 0.1, cameraAngle.phi - (e.clientY - previousMousePosition.y) * 0.01));
                previousMousePosition = { x: e.clientX, y: e.clientY };
                updateCameraPosition();
            });
            canvas.addEventListener('mouseup', () => isDragging = false);
            canvas.addEventListener('mouseleave', () => isDragging = false);
            canvas.addEventListener('wheel', (e) => { e.preventDefault(); cameraDistance = Math.max(2, Math.min(30, cameraDistance + e.deltaY * 0.01)); updateCameraPosition(); });
            const moveSpeed = 0.5; // tweak to taste

            window.addEventListener('keydown', (e) => {
                const key = e.key.toLowerCase();
                if (!['w', 'a', 's', 'd', 'q', 'e'].includes(key)) return;

                // current local basis
                const forward = new THREE.Vector3()
                    .subVectors(targetPosition, camera.position)  // from camera to target
                    .normalize();

                const worldUp = new THREE.Vector3(0, 1, 0);
                const right = new THREE.Vector3()
                    .crossVectors(forward, worldUp)
                    .normalize();

                const up = worldUp.clone();

                const delta = new THREE.Vector3();

                if (key === 'w') delta.add(forward);
                if (key === 's') delta.sub(forward);
                if (key === 'd') delta.add(right);
                if (key === 'a') delta.sub(right);
                if (key === 'q') delta.sub(up);
                if (key === 'e') delta.add(up);

                if (delta.lengthSq() === 0) return;

                delta.normalize().multiplyScalar(moveSpeed);

                // move the *offset*, not the raw target
                sceneOffset.add(delta);

                // recompute target & camera
                updateCameraPosition();
            });
        }

        function updateCameraPosition() {
            updateTargetPosition();
            camera.position.x = targetPosition.x + cameraDistance * Math.sin(cameraAngle.phi) * Math.sin(cameraAngle.theta);
            camera.position.y = targetPosition.y + cameraDistance * Math.cos(cameraAngle.phi);
            camera.position.z = targetPosition.z + cameraDistance * Math.sin(cameraAngle.phi) * Math.cos(cameraAngle.theta);
            camera.lookAt(targetPosition);
        }

        function setView(view) {
            if (view === 'front') cameraAngle = { theta: 0, phi: Math.PI / 2 };
            else if (view === 'side') cameraAngle = { theta: Math.PI / 2, phi: Math.PI / 2 };
            else if (view === 'top') cameraAngle = { theta: 0, phi: 0.1 };
            else { cameraAngle = { theta: 0.3, phi: Math.PI / 2.5 }; cameraDistance = 8; sceneOffset = new THREE.Vector3(0, 0, 0); targetPosition = new THREE.Vector3(0, 0, 0);}
            updateCameraPosition();
        }

        function onResize() {
            const container = renderer.domElement.parentElement;
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }

        function renderWallSections() {
            const container = document.getElementById('wall-sections');
            container.innerHTML = '';

            wallSections.forEach((section, index) => {
                const colorIndex = index % 8;
                const curveType = section.curveIntensity === 0 ? 'Flat' : (section.curveIntensity > 0 ? 'Concave' : 'Convex');
                
                // Ensure section has a name
                if (!section.name) section.name = `Wall ${index + 1}`;
                
                // Calculate canvas size and check if it exceeds 4K
                const canvasWidth = section.panelCols * section.ledX;
                const canvasHeight = section.panelRows * section.ledY;
                const summary = `${section.panelCols}×${section.panelRows} • ${canvasWidth}×${canvasHeight}px • ${curveType}`;
                
                const exceeds4K = (canvasWidth > 3840 || canvasHeight > 2160) && (canvasWidth > 2160 || canvasHeight > 3840);
                const warningHTML = exceeds4K ? `
                    <div class="section-warning">
                        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"/>
                            <line x1="12" y1="9" x2="12" y2="13"/><line x1="12" y1="17" x2="12.01" y2="17"/>
                        </svg>
                        <span>Canvas ${canvasWidth}×${canvasHeight} exceeds 4K</span>
                    </div>` : '';

                const sectionEl = document.createElement('div');
                sectionEl.className = 'wall-section collapsed';
                sectionEl.innerHTML = `
                    <div class="section-header">
                        <div class="section-header-left">
                            <div class="section-color" style="background: ${section.color}"></div>
                            <div>
                                <div class="section-title">${section.name}${exceeds4K ? ' <span class="warning-indicator">⚠</span>' : ''}</div>
                                <div class="section-summary">${summary}</div>
                            </div>
                        </div>
                        <div class="section-header-right">
                            ${wallSections.length > 1 ? `<button class="section-delete" data-id="${section.id}"><svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg></button>` : ''}
                            <div class="section-toggle"><svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="6 9 12 15 18 9"/></svg></div>
                        </div>
                    </div>
                    <div class="section-content">
                        ${warningHTML}
                        <div class="section-row single">
                            <div class="input-field">
                                <label>Section Name</label>
                                <input type="text" class="section-name-input" value="${section.name}" maxlength="32">
                            </div>
                        </div>
                        <div class="section-row">
                            <div class="input-field"><label>Columns</label><input type="number" data-field="panelCols" value="${section.panelCols}" min="1" max="50"></div>
                            <div class="input-field"><label>Rows</label><input type="number" data-field="panelRows" value="${section.panelRows}" min="1" max="20"></div>
                        </div>
                        <div class="section-row">
                            <div class="input-field"><label>Width (mm)</label><input type="number" data-field="panelWidth" value="${section.panelWidth}" min="50" max="5000"></div>
                            <div class="input-field"><label>Height (mm)</label><input type="number" data-field="panelHeight" value="${section.panelHeight}" min="50" max="5000"></div>
                        </div>
                        <div class="section-row">
                            <div class="input-field"><label>Pixels X</label><input type="number" data-field="ledX" value="${section.ledX}" min="8" max="350"></div>
                            <div class="input-field"><label>Pixels Y</label><input type="number" data-field="ledY" value="${section.ledY}" min="8" max="350"></div>
                        </div>
                        <div class="section-row single">
                            <div class="input-field">
                                <label>Angle Between Panels (°)</label>
                                <input type="number" data-field="curveIntensity" value="${section.curveIntensity}" min="-45" max="45" step="0.1">
                                <div class="curve-hint">${curveType}${section.curveIntensity !== 0 ? ` (${section.curveIntensity > 0 ? '+' : ''}${section.curveIntensity}°)` : ''}</div>
                            </div>
                        </div>
                        <div class="section-row single">
                            <div class="input-field">
                                <label>Panel Color</label>
                                <div class="section-color-picker">
                                    <div class="color-swatch-small ${section.color === '#00f0ff' ? 'active' : ''}" data-color="#00f0ff" style="background: #00f0ff;"></div>
                                    <div class="color-swatch-small ${section.color === '#ff00aa' ? 'active' : ''}" data-color="#ff00aa" style="background: #ff00aa;"></div>
                                    <div class="color-swatch-small ${section.color === '#00ff66' ? 'active' : ''}" data-color="#00ff66" style="background: #00ff66;"></div>
                                    <div class="color-swatch-small ${section.color === '#ff6b35' ? 'active' : ''}" data-color="#ff6b35" style="background: #ff6b35;"></div>
                                    <div class="color-swatch-small ${section.color === '#ffffff' ? 'active' : ''}" data-color="#ffffff" style="background: #ffffff;"></div>
                                    <div class="color-swatch-small ${section.color === '#ffdd00' ? 'active' : ''}" data-color="#ffdd00" style="background: #ffdd00;"></div>
                                    <input type="color" class="color-input-custom" value="${section.color}" title="Custom color">
                                </div>
                            </div>
                        </div>
                    </div>`;

                container.appendChild(sectionEl);

                sectionEl.querySelector('.section-header').addEventListener('click', (e) => {
                    if (!e.target.closest('.section-delete')) sectionEl.classList.toggle('collapsed');
                });

                const deleteBtn = sectionEl.querySelector('.section-delete');
                if (deleteBtn) deleteBtn.addEventListener('click', (e) => { e.stopPropagation(); deleteSection(section.id); });

                // Color swatches
                sectionEl.querySelectorAll('.color-swatch-small').forEach(swatch => {
                    swatch.addEventListener('click', (e) => {
                        e.stopPropagation();
                        sectionEl.querySelectorAll('.color-swatch-small').forEach(s => s.classList.remove('active'));
                        swatch.classList.add('active');
                        section.color = swatch.dataset.color;
                        sectionEl.querySelector('.section-color').style.background = section.color;
                        sectionEl.querySelector('.color-input-custom').value = section.color;
                        createLEDWall();
                    });
                });

                // Custom color input
                sectionEl.querySelector('.color-input-custom').addEventListener('input', (e) => {
                    e.stopPropagation();
                    section.color = e.target.value;
                    sectionEl.querySelectorAll('.color-swatch-small').forEach(s => s.classList.remove('active'));
                    sectionEl.querySelector('.section-color').style.background = section.color;
                    createLEDWall();
                });

                // Section name input
                sectionEl.querySelector('.section-name-input').addEventListener('input', (e) => {
                    e.stopPropagation();
                    section.name = e.target.value || `Wall ${index + 1}`;
                    sectionEl.querySelector('.section-title').innerHTML = section.name + 
                        (sectionEl.querySelector('.warning-indicator') ? ' <span class="warning-indicator">⚠</span>' : '');
                    if (panelIdsEnabled) createLEDWall();
                });
                sectionEl.querySelector('.section-name-input').addEventListener('click', (e) => e.stopPropagation());

                sectionEl.querySelectorAll('input[type="number"]').forEach(input => {
                    input.addEventListener('change', (e) => {
                        const field = e.target.dataset.field;
                        let value = parseFloat(e.target.value);
                        if (field === 'panelCols') value = Math.max(1, Math.min(50, value || 1));
                        else if (field === 'panelRows') value = Math.max(1, Math.min(20, value || 1));
                        else if (field === 'panelWidth' || field === 'panelHeight') value = Math.max(50, Math.min(5000, value || 500));
                        else if (field === 'ledX' || field === 'ledY') value = Math.max(8, Math.min(350, value || 32));
                        else if (field === 'curveIntensity') value = Math.max(-45, Math.min(45, value || 0));
                        e.target.value = value;
                        section[field] = value;
                        
                        // Update curve hint
                        if (field === 'curveIntensity') {
                            const hint = sectionEl.querySelector('.curve-hint');
                            const ct = value === 0 ? 'Flat' : (value > 0 ? 'Concave' : 'Convex');
                            hint.textContent = `${ct}${value !== 0 ? ` (${value > 0 ? '+' : ''}${value}°)` : ''}`;
                        }
                        
                        // Update summary with pixel dimensions
                        const canvasWidth = section.panelCols * section.ledX;
                        const canvasHeight = section.panelRows * section.ledY;
                        const curveType = section.curveIntensity === 0 ? 'Flat' : (section.curveIntensity > 0 ? 'Concave' : 'Convex');
                        sectionEl.querySelector('.section-summary').textContent = `${section.panelCols}×${section.panelRows} • ${canvasWidth}×${canvasHeight}px • ${curveType}`;
                        
                        // Update 4K warning
                        const exceeds4K = (canvasWidth > 3840 || canvasHeight > 2160) && (canvasWidth > 2160 || canvasHeight > 3840);
                        const existingWarning = sectionEl.querySelector('.section-warning');
                        const titleEl = sectionEl.querySelector('.section-title');
                        
                        if (exceeds4K && !existingWarning) {
                            const warningEl = document.createElement('div');
                            warningEl.className = 'section-warning';
                            warningEl.innerHTML = `<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"/><line x1="12" y1="9" x2="12" y2="13"/><line x1="12" y1="17" x2="12.01" y2="17"/></svg><span>Canvas ${canvasWidth}×${canvasHeight} exceeds 4K</span>`;
                            sectionEl.querySelector('.section-content').insertBefore(warningEl, sectionEl.querySelector('.section-content').firstChild);
                            if (!titleEl.innerHTML.includes('warning-indicator')) {
                                titleEl.innerHTML = titleEl.innerHTML.replace(/Wall \d+/, `$& <span class="warning-indicator">⚠</span>`);
                            }
                        } else if (!exceeds4K && existingWarning) {
                            existingWarning.remove();
                            titleEl.innerHTML = titleEl.innerHTML.replace(/ <span class="warning-indicator">⚠<\/span>/, '');
                        } else if (exceeds4K && existingWarning) {
                            existingWarning.querySelector('span').textContent = `Canvas ${canvasWidth}×${canvasHeight} exceeds 4K`;
                        }
                        
                        updateStats();
                        createLEDWall();
                    });
                    input.addEventListener('click', (e) => e.stopPropagation());
                });
            });
        }

        function addSection() {
            // Save collapsed states BEFORE adding new section
            const collapsedStates = {};
            document.querySelectorAll('.wall-section').forEach((el, idx) => {
                collapsedStates[wallSections[idx].id] = el.classList.contains('collapsed');
            });
            
            const last = wallSections[wallSections.length - 1];
            const newColorIndex = wallSections.length % sectionColors.length;
            const newSection = { 
                id: nextSectionId++,
                name: `Wall ${wallSections.length + 1}`,
                panelCols: last.panelCols, 
                panelRows: last.panelRows, 
                panelWidth: last.panelWidth, 
                panelHeight: last.panelHeight, 
                ledX: last.ledX, 
                ledY: last.ledY, 
                curveIntensity: last.curveIntensity,
                color: sectionColors[newColorIndex]
            };
            wallSections.push(newSection);
            
            renderWallSections();
            
            // Restore collapsed states and expand new section
            document.querySelectorAll('.wall-section').forEach((el, idx) => {
                const section = wallSections[idx];
                if (section.id === newSection.id) {
                    el.classList.remove('collapsed'); // New section expanded
                } else if (collapsedStates[section.id] !== undefined) {
                    el.classList.toggle('collapsed', collapsedStates[section.id]);
                }
            });
            
            createLEDWall();
        }

        function deleteSection(id) {
            if (wallSections.length <= 1) return;
            
            // Save collapsed states before re-render
            const collapsedStates = {};
            document.querySelectorAll('.wall-section').forEach((el, idx) => {
                collapsedStates[wallSections[idx].id] = el.classList.contains('collapsed');
            });
            
            wallSections = wallSections.filter(s => s.id !== id);
            renderWallSections();
            
            // Restore collapsed states
            document.querySelectorAll('.wall-section').forEach((el, idx) => {
                const section = wallSections[idx];
                if (collapsedStates[section.id] !== undefined) {
                    el.classList.toggle('collapsed', collapsedStates[section.id]);
                }
            });
            
            createLEDWall();
        }

        function setupUI() {
            renderWallSections();
            // Expand the first section on initial load
            const firstSection = document.querySelector('.wall-section');
            if (firstSection) firstSection.classList.remove('collapsed');
            
            document.getElementById('add-section-btn').addEventListener('click', addSection);

            document.querySelectorAll('.mesh-mode-option').forEach(opt => {
                opt.addEventListener('click', () => {
                    document.querySelectorAll('.mesh-mode-option').forEach(o => o.classList.remove('active'));
                    opt.classList.add('active');
                    meshMode = opt.dataset.mode;
                    createLEDWall();
                });
            });

            document.getElementById('toggle-wireframe').addEventListener('click', function() { this.classList.toggle('active'); wireframeEnabled = this.classList.contains('active'); createLEDWall(); });
            document.getElementById('toggle-frame').addEventListener('click', function() { this.classList.toggle('active'); showFrame = this.classList.contains('active'); createLEDWall(); });
            document.getElementById('toggle-led-sim').addEventListener('click', function() { 
                this.classList.toggle('active'); 
                ledSimEnabled = this.classList.contains('active'); 
                document.getElementById('animation-toggle-container').style.display = ledSimEnabled ? 'flex' : 'none'; 
                // Disable panel IDs if LED sim is enabled
                if (ledSimEnabled && panelIdsEnabled) {
                    panelIdsEnabled = false;
                    document.getElementById('toggle-panel-ids').classList.remove('active');
                    document.getElementById('panel-id-options').style.display = 'none';
                }
                createLEDWall(); 
            });
            document.getElementById('toggle-animation').addEventListener('click', function() { this.classList.toggle('active'); animationEnabled = this.classList.contains('active'); });

            // Panel ID handlers
            document.getElementById('toggle-panel-ids').addEventListener('click', function() { 
                this.classList.toggle('active'); 
                panelIdsEnabled = this.classList.contains('active'); 
                document.getElementById('panel-id-options').style.display = panelIdsEnabled ? 'block' : 'none';
                // Disable LED sim if panel IDs is enabled
                if (panelIdsEnabled && ledSimEnabled) {
                    ledSimEnabled = false;
                    document.getElementById('toggle-led-sim').classList.remove('active');
                    document.getElementById('animation-toggle-container').style.display = 'none';
                }
                createLEDWall(); 
            });
            document.getElementById('panel-border-thickness').addEventListener('change', function() {
                panelBorderThickness = Math.max(1, Math.min(32, parseInt(this.value) || 8));
                this.value = panelBorderThickness;
                if (panelIdsEnabled) createLEDWall();
            });
            document.getElementById('panel-font-size').addEventListener('change', function() {
                panelFontSize = Math.max(0, Math.min(200, parseInt(this.value) || 0));
                this.value = panelFontSize;
                if (panelIdsEnabled) createLEDWall();
            });
            document.getElementById('panel-font-color').addEventListener('input', function() {
                panelIdFontColor = this.value;
                if (panelIdsEnabled) createLEDWall();
            });
            document.getElementById('toggle-section-labels').addEventListener('click', function() {
                this.classList.toggle('active');
                sectionLabelEnabled = this.classList.contains('active');
                if (panelIdsEnabled) createLEDWall();
            });
            document.getElementById('section-label-size').addEventListener('change', function() {
                sectionLabelFontSize = Math.max(0, Math.min(400, parseInt(this.value) || 0));
                this.value = sectionLabelFontSize;
                if (panelIdsEnabled) createLEDWall();
            });
            document.getElementById('section-label-color').addEventListener('input', function() {
                sectionLabelColor = this.value;
                if (panelIdsEnabled) createLEDWall();
            });

            document.getElementById('view-front').addEventListener('click', () => setView('front'));
            document.getElementById('view-side').addEventListener('click', () => setView('side'));
            document.getElementById('view-top').addEventListener('click', () => setView('top'));
            document.getElementById('view-reset').addEventListener('click', () => setView('reset'));

            // Export/Import handlers
            document.getElementById('export-zip').addEventListener('click', exportZIP);
            document.getElementById('export-panel-ids').addEventListener('click', exportPanelIds);
            document.getElementById('export-json').addEventListener('click', exportJSON);
            document.getElementById('export-obj').addEventListener('click', exportOBJ);
            document.getElementById('export-gltf').addEventListener('click', exportGLTF);
            document.getElementById('import-json').addEventListener('click', () => document.getElementById('import-input').click());
            document.getElementById('import-input').addEventListener('change', importJSON);
        }

        async function exportZIP() {
            const zip = new JSZip();
            const scale = 0.002;
            
            // Helper function to sanitize filename
            const sanitizeFilename = (name) => name.replace(/[^a-zA-Z0-9_-]/g, '_');
            
            // Add JSON config
            const jsonData = {
                version: '1.0',
                sections: wallSections.map((s, i) => ({
                    name: s.name || `Wall ${i + 1}`,
                    id: s.id,
                    panel: { columns: s.panelCols, rows: s.panelRows, width_mm: s.panelWidth, height_mm: s.panelHeight },
                    led_resolution: { x: s.ledX, y: s.ledY, pixel_pitch_mm: parseFloat((s.panelWidth / s.ledX).toFixed(2)) },
                    curvature: { 
                        type: s.curveIntensity === 0 ? 'flat' : (s.curveIntensity > 0 ? 'concave' : 'convex'), 
                        angle_degrees: s.curveIntensity 
                    },
                    color: s.color,
                    texture_file: `textures/${sanitizeFilename(s.name || `Wall_${i + 1}`)}_PanelIDs.png`
                })),
                mesh_mode: meshMode,
                totals: {
                    sections: wallSections.length,
                    total_panels: wallSections.reduce((sum, s) => sum + s.panelCols * s.panelRows, 0),
                    total_pixels: wallSections.reduce((sum, s) => sum + s.panelCols * s.panelRows * s.ledX * s.ledY, 0)
                }
            };
            zip.file('led-wall-config.json', JSON.stringify(jsonData, null, 2));

            // Generate OBJ content
            const allSectionsGeometry = generateAllSectionsGeometry(scale);
            const { objContent, mtlContent } = generateOBJContent(allSectionsGeometry, scale);
            zip.file('led-wall-config.obj', objContent);
            zip.file('led-wall-config.mtl', mtlContent);

            // Generate glTF content
            const gltfContent = generateGLTFContent(allSectionsGeometry);
            zip.file('led-wall-config.gltf', JSON.stringify(gltfContent, null, 2));

            // Generate Panel ID textures for each section with cumulative columns
            const texturesFolder = zip.folder('textures');
            let cumulativeCol = 0;
            for (let i = 0; i < wallSections.length; i++) {
                const section = wallSections[i];
                const canvas = createSectionPanelIdCanvas(section, i, null, cumulativeCol);
                const dataUrl = canvas.toDataURL('image/png');
                const base64Data = dataUrl.split(',')[1];
                const filename = `${sanitizeFilename(section.name || `Wall_${i + 1}`)}_PanelIDs.png`;
                texturesFolder.file(filename, base64Data, { base64: true });
                cumulativeCol += section.panelCols;
            }

            // Generate and download ZIP
            const content = await zip.generateAsync({ type: 'blob' });
            const a = document.createElement('a');
            a.href = URL.createObjectURL(content);
            a.download = 'led-wall-export.zip';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(a.href);
        }

        function generateOBJContent(allSectionsGeometry, scale) {
            let objContent = '# LED Wall Configuration OBJ Export\n';
            objContent += `# Mesh Mode: ${meshMode}\n`;
            objContent += '# Generated by LED Wall Configurator\n\n';
            
            let mtlContent = '# LED Wall Materials\n\n';

            if (meshMode === 'combined') {
                const color = new THREE.Color(wallSections[0].color);
                mtlContent += `newmtl LED_Wall_Combined\n`;
                mtlContent += `Kd ${color.r.toFixed(4)} ${color.g.toFixed(4)} ${color.b.toFixed(4)}\n`;
                mtlContent += `Ka 0.1 0.1 0.1\nKs 0.5 0.5 0.5\nNs 100\nd 1.0\n\n`;

                objContent += 'mtllib led-wall-config.mtl\n\n';
                objContent += 'o LED_Wall_Combined\n';
                objContent += 'usemtl LED_Wall_Combined\n';

                let vertexOffset = 1;
                
                allSectionsGeometry.forEach(({ vertices }) => {
                    for (let i = 0; i < vertices.length; i += 3) {
                        objContent += `v ${vertices[i].toFixed(6)} ${vertices[i+1].toFixed(6)} ${vertices[i+2].toFixed(6)}\n`;
                    }
                });

                allSectionsGeometry.forEach(({ section }) => {
                    for (let row = 0; row <= section.panelRows; row++) {
                        for (let col = 0; col <= section.panelCols; col++) {
                            objContent += `vt ${(col / section.panelCols).toFixed(6)} ${(row / section.panelRows).toFixed(6)}\n`;
                        }
                    }
                });

                objContent += 'vn 0 0 1\n';

                allSectionsGeometry.forEach(({ section }) => {
                    const vertsPerRow = section.panelCols + 1;
                    for (let row = 0; row < section.panelRows; row++) {
                        for (let col = 0; col < section.panelCols; col++) {
                            const bl = vertexOffset + row * vertsPerRow + col;
                            const br = bl + 1;
                            const tl = vertexOffset + (row + 1) * vertsPerRow + col;
                            const tr = tl + 1;
                            objContent += `f ${bl}/${bl}/1 ${tl}/${tl}/1 ${tr}/${tr}/1\n`;
                            objContent += `f ${bl}/${bl}/1 ${tr}/${tr}/1 ${br}/${br}/1\n`;
                        }
                    }
                    vertexOffset += (section.panelCols + 1) * (section.panelRows + 1);
                });

            } else if (meshMode === 'section') {
                wallSections.forEach((section, i) => {
                    const color = new THREE.Color(section.color);
                    mtlContent += `newmtl Wall_${i + 1}\n`;
                    mtlContent += `Kd ${color.r.toFixed(4)} ${color.g.toFixed(4)} ${color.b.toFixed(4)}\n`;
                    mtlContent += `Ka 0.1 0.1 0.1\nKs 0.5 0.5 0.5\nNs 100\nd 1.0\n`;
                    mtlContent += `map_Kd textures/Wall_${i + 1}_PanelIDs.png\n\n`;
                });

                objContent += 'mtllib led-wall-config.mtl\n\n';

                let vertexOffset = 1;
                let texCoordOffset = 1;
                let normalOffset = 1;
                
                allSectionsGeometry.forEach(({ section, vertices }, sectionIndex) => {
                    objContent += `o Wall_${sectionIndex + 1}\n`;
                    objContent += `usemtl Wall_${sectionIndex + 1}\n`;

                    for (let i = 0; i < vertices.length; i += 3) {
                        objContent += `v ${vertices[i].toFixed(6)} ${vertices[i+1].toFixed(6)} ${vertices[i+2].toFixed(6)}\n`;
                    }

                    for (let row = 0; row <= section.panelRows; row++) {
                        for (let col = 0; col <= section.panelCols; col++) {
                            objContent += `vt ${(col / section.panelCols).toFixed(6)} ${(row / section.panelRows).toFixed(6)}\n`;
                        }
                    }

                    objContent += `vn 0 0 1\n`;

                    const vertsPerRow = section.panelCols + 1;
                    for (let row = 0; row < section.panelRows; row++) {
                        for (let col = 0; col < section.panelCols; col++) {
                            const bl = vertexOffset + row * vertsPerRow + col;
                            const br = bl + 1;
                            const tl = vertexOffset + (row + 1) * vertsPerRow + col;
                            const tr = tl + 1;
                            const tbl = texCoordOffset + row * vertsPerRow + col;
                            const tbr = tbl + 1;
                            const ttl = texCoordOffset + (row + 1) * vertsPerRow + col;
                            const ttr = ttl + 1;
                            objContent += `f ${bl}/${tbl}/${normalOffset} ${tl}/${ttl}/${normalOffset} ${tr}/${ttr}/${normalOffset}\n`;
                            objContent += `f ${bl}/${tbl}/${normalOffset} ${tr}/${ttr}/${normalOffset} ${br}/${tbr}/${normalOffset}\n`;
                        }
                    }

                    const numVerts = (section.panelCols + 1) * (section.panelRows + 1);
                    vertexOffset += numVerts;
                    texCoordOffset += numVerts;
                    normalOffset += 1;
                    objContent += '\n';
                });

            } else {
                wallSections.forEach((section, i) => {
                    const color = new THREE.Color(section.color);
                    mtlContent += `newmtl Wall_${i + 1}\n`;
                    mtlContent += `Kd ${color.r.toFixed(4)} ${color.g.toFixed(4)} ${color.b.toFixed(4)}\n`;
                    mtlContent += `Ka 0.1 0.1 0.1\nKs 0.5 0.5 0.5\nNs 100\nd 1.0\n\n`;
                });

                objContent += 'mtllib led-wall-config.mtl\n\n';

                let vertexOffset = 1;
                let texCoordOffset = 1;
                let normalOffset = 1;
                
                allSectionsGeometry.forEach(({ section, panelData, panelW, panelH }, sectionIndex) => {
                    panelData.forEach((panel) => {
                        const panelName = `Wall_${sectionIndex + 1}_Panel_R${panel.row + 1}_C${panel.col + 1}`;
                        objContent += `o ${panelName}\n`;
                        objContent += `usemtl Wall_${sectionIndex + 1}\n`;

                        const hw = panelW / 2;
                        const hh = panelH / 2;
                        const cos = Math.cos(panel.rotY);
                        const sin = Math.sin(panel.rotY);

                        const corners = [
                            { x: panel.x + (-hw) * cos, y: panel.y - hh, z: panel.z - (-hw) * sin },
                            { x: panel.x + (hw) * cos,  y: panel.y - hh, z: panel.z - (hw) * sin },
                            { x: panel.x + (hw) * cos,  y: panel.y + hh, z: panel.z - (hw) * sin },
                            { x: panel.x + (-hw) * cos, y: panel.y + hh, z: panel.z - (-hw) * sin }
                        ];

                        corners.forEach(c => {
                            objContent += `v ${c.x.toFixed(6)} ${c.y.toFixed(6)} ${c.z.toFixed(6)}\n`;
                        });

                        objContent += `vt 0 0\nvt 1 0\nvt 1 1\nvt 0 1\n`;

                        const nx = Math.sin(panel.rotY);
                        const nz = Math.cos(panel.rotY);
                        objContent += `vn ${nx.toFixed(6)} 0 ${nz.toFixed(6)}\n`;

                        const v = vertexOffset;
                        const t = texCoordOffset;
                        const n = normalOffset;
                        objContent += `f ${v}/${t}/${n} ${v+3}/${t+3}/${n} ${v+2}/${t+2}/${n}\n`;
                        objContent += `f ${v}/${t}/${n} ${v+2}/${t+2}/${n} ${v+1}/${t+1}/${n}\n`;

                        vertexOffset += 4;
                        texCoordOffset += 4;
                        normalOffset += 1;
                        objContent += '\n';
                    });
                });
            }

            return { objContent, mtlContent };
        }

        function generateGLTFContent(allSectionsGeometry) {
            const gltf = {
                asset: { version: "2.0", generator: "LED Wall Configurator" },
                scene: 0,
                scenes: [{ nodes: [] }],
                nodes: [],
                meshes: [],
                accessors: [],
                bufferViews: [],
                buffers: [],
                materials: []
            };

            const allBufferData = [];
            let byteOffset = 0;
            let accessorIndex = 0;
            let meshIndex = 0;

            function addMesh(name, vertices, indices, color) {
                const materialIndex = gltf.materials.length;
                gltf.materials.push({
                    name: name + "_Material",
                    pbrMetallicRoughness: {
                        baseColorFactor: [color.r, color.g, color.b, 1.0],
                        metallicFactor: 0.0,
                        roughnessFactor: 0.8
                    }
                });

                const vertexBuffer = new Float32Array(vertices);
                const vertexBytes = new Uint8Array(vertexBuffer.buffer);
                allBufferData.push(vertexBytes);
                
                const vertexBufferView = gltf.bufferViews.length;
                gltf.bufferViews.push({
                    buffer: 0,
                    byteOffset: byteOffset,
                    byteLength: vertexBytes.length,
                    target: 34962
                });
                byteOffset += vertexBytes.length;
                const vertPadding = (4 - (byteOffset % 4)) % 4;
                if (vertPadding > 0) {
                    allBufferData.push(new Uint8Array(vertPadding));
                    byteOffset += vertPadding;
                }

                let minX = Infinity, minY = Infinity, minZ = Infinity;
                let maxX = -Infinity, maxY = -Infinity, maxZ = -Infinity;
                for (let i = 0; i < vertices.length; i += 3) {
                    minX = Math.min(minX, vertices[i]);
                    maxX = Math.max(maxX, vertices[i]);
                    minY = Math.min(minY, vertices[i + 1]);
                    maxY = Math.max(maxY, vertices[i + 1]);
                    minZ = Math.min(minZ, vertices[i + 2]);
                    maxZ = Math.max(maxZ, vertices[i + 2]);
                }

                const positionAccessor = accessorIndex++;
                gltf.accessors.push({
                    bufferView: vertexBufferView,
                    byteOffset: 0,
                    componentType: 5126,
                    count: vertices.length / 3,
                    type: "VEC3",
                    min: [minX, minY, minZ],
                    max: [maxX, maxY, maxZ]
                });

                const indexBuffer = new Uint16Array(indices);
                const indexBytes = new Uint8Array(indexBuffer.buffer);
                allBufferData.push(indexBytes);
                
                const indexBufferView = gltf.bufferViews.length;
                gltf.bufferViews.push({
                    buffer: 0,
                    byteOffset: byteOffset,
                    byteLength: indexBytes.length,
                    target: 34963
                });
                byteOffset += indexBytes.length;
                const idxPadding = (4 - (byteOffset % 4)) % 4;
                if (idxPadding > 0) {
                    allBufferData.push(new Uint8Array(idxPadding));
                    byteOffset += idxPadding;
                }

                const indexAccessor = accessorIndex++;
                gltf.accessors.push({
                    bufferView: indexBufferView,
                    byteOffset: 0,
                    componentType: 5123,
                    count: indices.length,
                    type: "SCALAR"
                });

                const currentMeshIndex = meshIndex++;
                gltf.meshes.push({
                    name: name,
                    primitives: [{
                        attributes: { POSITION: positionAccessor },
                        indices: indexAccessor,
                        material: materialIndex
                    }]
                });

                const nodeIndex = gltf.nodes.length;
                gltf.nodes.push({ name: name, mesh: currentMeshIndex });
                gltf.scenes[0].nodes.push(nodeIndex);
            }

            if (meshMode === 'combined') {
                const allVertices = [];
                const allIndices = [];
                let indexOffset = 0;

                allSectionsGeometry.forEach(({ section, vertices }) => {
                    for (let i = 0; i < vertices.length; i++) allVertices.push(vertices[i]);
                    const vertsPerRow = section.panelCols + 1;
                    for (let row = 0; row < section.panelRows; row++) {
                        for (let col = 0; col < section.panelCols; col++) {
                            const bl = indexOffset + row * vertsPerRow + col;
                            const br = bl + 1;
                            const tl = indexOffset + (row + 1) * vertsPerRow + col;
                            const tr = tl + 1;
                            allIndices.push(bl, tl, tr, bl, tr, br);
                        }
                    }
                    indexOffset += (section.panelCols + 1) * (section.panelRows + 1);
                });

                const color = new THREE.Color(wallSections[0].color);
                addMesh('LED_Wall_Combined', allVertices, allIndices, color);

            } else if (meshMode === 'section') {
                allSectionsGeometry.forEach(({ section, vertices }, sectionIndex) => {
                    const indices = [];
                    const vertsPerRow = section.panelCols + 1;
                    for (let row = 0; row < section.panelRows; row++) {
                        for (let col = 0; col < section.panelCols; col++) {
                            const bl = row * vertsPerRow + col;
                            const br = bl + 1;
                            const tl = (row + 1) * vertsPerRow + col;
                            const tr = tl + 1;
                            indices.push(bl, tl, tr, bl, tr, br);
                        }
                    }
                    const color = new THREE.Color(section.color);
                    addMesh(`Wall_${sectionIndex + 1}`, vertices, indices, color);
                });

            } else {
                allSectionsGeometry.forEach(({ section, panelData, panelW, panelH }, sectionIndex) => {
                    const color = new THREE.Color(section.color);

                    panelData.forEach((panel) => {
                        const hw = panelW / 2;
                        const hh = panelH / 2;
                        const cos = Math.cos(panel.rotY);
                        const sin = Math.sin(panel.rotY);

                        const vertices = [
                            panel.x + (-hw) * cos, panel.y - hh, panel.z - (-hw) * sin,
                            panel.x + (hw) * cos,  panel.y - hh, panel.z - (hw) * sin,
                            panel.x + (hw) * cos,  panel.y + hh, panel.z - (hw) * sin,
                            panel.x + (-hw) * cos, panel.y + hh, panel.z - (-hw) * sin
                        ];

                        const indices = [0, 3, 2, 0, 2, 1];
                        const name = `Wall_${sectionIndex + 1}_Panel_R${panel.row + 1}_C${panel.col + 1}`;
                        addMesh(name, vertices, indices, color);
                    });
                });
            }

            const totalLength = allBufferData.reduce((sum, arr) => sum + arr.length, 0);
            const combinedBuffer = new Uint8Array(totalLength);
            let offset = 0;
            for (const arr of allBufferData) {
                combinedBuffer.set(arr, offset);
                offset += arr.length;
            }

            const base64 = btoa(String.fromCharCode(...combinedBuffer));
            gltf.buffers.push({
                byteLength: combinedBuffer.length,
                uri: "data:application/octet-stream;base64," + base64
            });

            return gltf;
        }

        function exportOBJ() {
            const scale = 0.002;
            const allSectionsGeometry = generateAllSectionsGeometry(scale);
            const { objContent, mtlContent } = generateOBJContent(allSectionsGeometry, scale);
            downloadFile(objContent, 'led-wall-config.obj', 'text/plain');
            setTimeout(() => downloadFile(mtlContent, 'led-wall-config.mtl', 'text/plain'), 100);
        }

        function exportGLTF() {
            const scale = 0.002;
            const allSectionsGeometry = generateAllSectionsGeometry(scale);
            const gltfContent = generateGLTFContent(allSectionsGeometry);
            downloadFile(JSON.stringify(gltfContent, null, 2), 'led-wall-config.gltf', 'application/json');
        }

        async function exportPanelIds() {
            // Create a combined canvas with all sections
            const combinedCanvas = createCombinedPanelIdCanvas();
            
            // Convert to blob and download
            combinedCanvas.toBlob((blob) => {
                const a = document.createElement('a');
                a.href = URL.createObjectURL(blob);
                a.download = 'panel-ids.png';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(a.href);
            }, 'image/png');
        }

        function exportJSON() {
            const exportData = {
                version: '1.0',
                sections: wallSections.map((s, i) => ({
                    name: s.name || `Wall ${i + 1}`,
                    id: s.id,
                    panel: { columns: s.panelCols, rows: s.panelRows, width_mm: s.panelWidth, height_mm: s.panelHeight },
                    led_resolution: { x: s.ledX, y: s.ledY, pixel_pitch_mm: parseFloat((s.panelWidth / s.ledX).toFixed(2)) },
                    curvature: { 
                        type: s.curveIntensity === 0 ? 'flat' : (s.curveIntensity > 0 ? 'concave' : 'convex'), 
                        angle_degrees: s.curveIntensity 
                    },
                    color: s.color
                })),
                mesh_mode: meshMode,
                totals: {
                    sections: wallSections.length,
                    total_panels: wallSections.reduce((sum, s) => sum + s.panelCols * s.panelRows, 0),
                    total_pixels: wallSections.reduce((sum, s) => sum + s.panelCols * s.panelRows * s.ledX * s.ledY, 0)
                }
            };
            downloadFile(JSON.stringify(exportData, null, 2), 'led-wall-config.json', 'application/json');
        }

        function importJSON(e) {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (event) => {
                try {
                    const data = JSON.parse(event.target.result);
                    if (data.sections && Array.isArray(data.sections)) {
                        wallSections = data.sections.map((s, i) => ({
                            id: s.id !== undefined ? s.id : i,
                            name: s.name || `Wall ${i + 1}`,
                            panelCols: s.panel?.columns || 5,
                            panelRows: s.panel?.rows || 3,
                            panelWidth: s.panel?.width_mm || 500,
                            panelHeight: s.panel?.height_mm || 500,
                            ledX: s.led_resolution?.x || 32,
                            ledY: s.led_resolution?.y || 32,
                            curveIntensity: s.curvature?.angle_degrees || 0,
                            color: s.color || sectionColors[i % sectionColors.length]
                        }));
                        nextSectionId = Math.max(...wallSections.map(s => s.id)) + 1;
                        
                        if (data.mesh_mode) {
                            meshMode = data.mesh_mode;
                            document.querySelectorAll('.mesh-mode-option').forEach(o => {
                                o.classList.toggle('active', o.dataset.mode === meshMode);
                            });
                        }
                        
                        renderWallSections();
                        // Expand first section after import
                        const firstSection = document.querySelector('.wall-section');
                        if (firstSection) firstSection.classList.remove('collapsed');
                        createLEDWall();
                    }
                } catch (err) {
                    alert('Error parsing JSON file: ' + err.message);
                }
            };
            reader.readAsText(file);
            e.target.value = ''; // Reset input
        }

        function generateAllSectionsGeometry(scale) {
            const allSectionsGeometry = [];
            let currentX = 0, currentZ = 0, currentAngle = 0;

            wallSections.forEach((section, sectionIndex) => {
                const panelW = section.panelWidth * scale;
                const panelH = section.panelHeight * scale;
                const curveAngleRad = (Math.abs(section.curveIntensity) * Math.PI) / 180;
                const isFlat = section.curveIntensity === 0;
                const dirMult = section.curveIntensity > 0 ? 1 : (section.curveIntensity < 0 ? -1 : 0);

                const edgePositions = [{ x: currentX, z: currentZ }];
                const startAngle = currentAngle;

                for (let col = 0; col < section.panelCols; col++) {
                    // Apply curve BEFORE movement (so first panel is also curved)
                    if (!isFlat) {
                        currentAngle += curveAngleRad;
                    }

                    const moveAngle = currentAngle * (dirMult !== 0 ? dirMult : 1);
                    if (isFlat && startAngle === 0 && edgePositions.length === 1) {
                        // Pure flat section starting from origin
                        currentX += panelW;
                    } else {
                        currentX += panelW * Math.cos(moveAngle);
                        currentZ += panelW * Math.sin(moveAngle);
                    }
                    edgePositions.push({ x: currentX, z: currentZ });
                }

                // Generate vertices
                const vertices = [];
                for (let row = 0; row <= section.panelRows; row++) {
                    const y = row * panelH;
                    for (let col = 0; col <= section.panelCols; col++) {
                        const edge = edgePositions[col];
                        vertices.push(edge.x, y, edge.z);
                    }
                }

                // Generate panel data for individual panels mode
                const panelData = [];
                for (let row = 0; row < section.panelRows; row++) {
                    const y = row * panelH;
                    for (let col = 0; col < section.panelCols; col++) {
                        const leftEdge = edgePositions[col];
                        const rightEdge = edgePositions[col + 1];
                        const centerX = (leftEdge.x + rightEdge.x) / 2;
                        const centerZ = (leftEdge.z + rightEdge.z) / 2;
                        const centerY = y + panelH / 2;
                        const dx = rightEdge.x - leftEdge.x;
                        const dz = rightEdge.z - leftEdge.z;
                        const rotY = -Math.atan2(dz, dx);

                        panelData.push({ x: centerX, y: centerY, z: centerZ, rotY, col, row });
                    }
                }

                allSectionsGeometry.push({
                    section,
                    sectionIndex,
                    vertices,
                    edgePositions,
                    panelData,
                    panelW,
                    panelH
                });
            });

            return allSectionsGeometry;
        }

        function downloadFile(content, filename, mimeType) {
            const blob = new Blob([content], { type: mimeType });
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(a.href);
        }

        init();
        setupUI();
        setView('reset');
    </script>
</body>
</html>
